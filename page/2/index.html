<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Hackecho</title>
  <meta name="author" content="Zhaoyu Li">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hackecho"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hackecho" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hackecho</a></h1>
  <h2><a href="/">Blog by Zhaoyu Li</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-11-03T21:01:47.000Z"><a href="/2012/11/disappear-day/">Nov 3 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/11/disappear-day/">消失的这几天</a></h1>
  

    </header>
    <div class="entry">
      
        <p>突然间，这里已经11月3日了，现在是凌晨1：20。在遥远的故乡，正是下午2：2o。朋友们，下午好。</p>
<p>好久没写东西了，哪怕是技术方面的，也没有一篇。最新的一篇日志还停留在7月份，记得那是离签证还有一星期的时候，忙里偷闲转的一篇。一转眼，万圣节已过，开始期盼Thanksgiving的时候，却发现到处都开始准备圣诞树了。时间好快，恍惚之间，不敢苟且。</p>
<p>如今，三个月过去了，每天的安排开始有了规律。不过回想起这三个月的种种，心头也会涌起一股莫名的感情。经常会想写一些东西记录，而一切变化太快，未等提笔，便已忙于身外，只能享受那片刻欢愉。</p>
<p>也许有一天，我会将这些见闻与经历写一写，而现在还没有准备好。因为没有经过沉淀的思想，永远都是肤浅的。有一天回忆的时候，我要找寻那种想哭的感动。</p>
<p>不过，我喜欢这种充实的生活，每一天都在创造价值，哥伦比亚是个小镇，宁静安详，不吵不闹，这里有传统的美国文化，也有纯真朴实的来自世界各地的人们，每天都有新发现，每天都会带给你新的的感受。</p>
<p>明天又将是充实的一天，Ellis图书馆的教堂式屋顶真的让我在第一次见到时目瞪口呆，而屋顶下是一群群怀有梦想的学子，这里，是梦开始的地方。</p>
<p>晚安。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-07-01T15:15:00.000Z"><a href="/2012/07/fhs-introduction/">Jul 1 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/07/fhs-introduction/">Linux文件系统备忘录</a></h1>
  

    </header>
    <div class="entry">
      
        <p>与Windows将硬盘看做“C盘”、“D盘”几个独立的分区不同，Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用/表示。各个分区通过“挂载”（Mount）以文件夹的形式访问。</p>
<p>在/中的文件夹很多，本文介绍常见文件夹的意义。Linux的目录结构确实比较复杂，但设置合理、层次鲜明。本文以<a href="http://www.pathname.com/fhs/" target="_blank">FHS 2.3</a>为例进行介绍。</p>
<h2 id="-">根文件系统</h2>
<p><strong>/bin</strong></p>
<p>这一目录中存放了供所有用户使用的完成基本维护任务的命令。其中bin是binary的缩写，表示二进制文件，通常为可执行文件。一些常用的系统命令，如cp、ls等保存在该目录中。</p>
<p><strong>/boot</strong></p>
<p>这里存放的是启动Linux时使用的一些核心文件。如操作系统内核、引导程序Grub等。</p>
<p><strong>/dev</strong></p>
<p>在此目录中包含所有的系统设备文件。从此目录可以访问各种系统设备。如CD-ROM，磁盘驱动器，调制解调器和内存等。在该目录中还包含有各种实用功能，如用于创建设备文件的MAKEDEV。</p>
<p><strong>/etc</strong></p>
<p>该目录中包含系统和应用软件的配置文件。</p>
<p><strong>/etc/passwd</strong></p>
<p>该目录中包含了系统中的用户描述信息，每行记录一个用户的信息。</p>
<p><strong>/home</strong></p>
<p>存储普通用户的个人文件。每个用户的主目录均在/home下以自己的用户名命名。</p>
<p><strong>/lib</strong></p>
<p>这个目录里存放着系统最基本的共享链接库和内核模块。共享链接库在功能上类似于Windows里的.dll文件。</p>
<p><strong>/lib64</strong></p>
<p>64位系统有这个文件夹，64位程序的库。</p>
<p><strong>/lost+found</strong></p>
<p>这并不是Linux目录结构的组成部分，而是ext3文件系统用于保存丢失文件的地方。不恰当的关机操作和磁盘错误均会导致文件丢失，这意味着这些被标注为“在使用”，但却并未列于磁盘上的数据结构上。正常情况下，引导进程会运行fsck程序，该程序能发现这些文件。除了“/”分区上的这个目录外，在每个分区上均有一个lost+found目录。</p>
<p><strong>/media</strong></p>
<p>可移动设备的挂载点，当前的操作系统通常会把U盘等设备自动挂载到该文件夹下。</p>
<p><strong>/mnt</strong></p>
<p>临时用于挂载文件系统的地方。一般情况下这个目录是空的，而在我们将要挂载分区时在这个目录下建立目录，再将我们将要访问的设备挂载在这个目录上，这样我们就可访问文件了。（注意在GNOME中，只有挂载到/media的文件夹才会显示在“计算机”中，挂载到/mnt不会做为特殊设备显示，详见自动挂载分区）</p>
<p><strong>/opt</strong></p>
<p>多数第三方软件默认安装到此位置，如Adobe Reader、google-earth等。并不是每个系统都会创建这个目录。</p>
<p><strong>/proc</strong></p>
<p>它是存在于内存中的虚拟文件系统。里面保存了内核和进程的状态信息。多为文本文件，可以直接查看。如/proc/cpuinfo保存了有关CPU的信息。</p>
<p><strong>/root</strong></p>
<p>这是根用户的主目录。与保留给个人用户的/home下的目录很相似，该目录中还包含仅与根用户有关的条目。</p>
<p><strong>/sbin</strong></p>
<p>供超级用户使用的可执行文件，里面多是系统管理命令，如fsck, reboot, shutdown, ifconfig等。</p>
<p><strong>/tmp</strong></p>
<p>该目录用以保存临时文件。该目录具有Sticky特殊权限，所有用户都可以在这个目录中创建、编辑文件。但只有文件拥有者才能删除文件。为了加快临时文件的访问速度，有的实现把/tmp放在内存中。</p>
<p><strong>/usr</strong></p>
<p>静态的用户级应用程序等，见下。</p>
<p><strong>/var</strong></p>
<p>动态的程序数据等，见下文。</p>
<h2 id="-usr-">/usr目录结构</h2>
<p>/usr通常是一个庞大的文件夹，其下的目录结构与根目录相似，但根目录中的文件多是系统级的文件，而/usr中是用户级的文件，一般与具体的系统无关。</p>
<pre><code>usr最早是user的缩写，/usr的作用与现在的/home相同。而目前其通常被认为是 User System Resources 的缩写，其中通常是用户级的软件等，与存放系统级文件的根目录形成对比。
</code></pre><p>应注意，程序的配置文件、动态的数据文件等都不会存放到/usr，所以除了安装、卸载软件外，一般无需修改/usr中的内容。说在系统正常运行时，/usr甚至可以被只读挂载。由于这一特性，/usr常被划分在单独的分区，甚至有时多台计算机可以共享一个/usr。</p>
<p><strong>/usr/bin</strong></p>
<p>多数日常应用程序存放的位置。如果/usr被放在单独的分区中，Linux的单用户模式不能访问/usr/bin，所以对系统至关重要的程序不应放在此文件夹中。</p>
<p><strong>/usr/include</strong></p>
<p>存放C/C++头文件的目录</p>
<p><strong>/usr/lib</strong></p>
<p>系统的库文件</p>
<p><strong>/usr/local</strong></p>
<p>新装的系统中这个文件夹是空的，可以用于存放个人安装的软件。安装了本地软件的/usr/local里的目录结构与/usr相似</p>
<p><strong>/usr/sbin</strong></p>
<p>在单用户模式中不用的系统管理程序，如apache2等。</p>
<p><strong>/usr/share</strong></p>
<p>与架构无关的数据。多数软件安装在此。</p>
<p><strong>/usr/X11R6</strong></p>
<p>该目录用于保存运行X-Window所需的所有文件。该目录中还包含用于运行GUI要的配置文件和二进制文件。</p>
<p><strong>/usr/src</strong></p>
<p>源代码</p>
<h2 id="-var-">/var目录结构</h2>
<p>/var中包括了一些数据文件，如系统日志等。/var的存放使得/usr被只读挂载成为可能。</p>
<p><strong>/var/cache</strong></p>
<p>应用程序的缓存文件</p>
<p><strong>/var/lib</strong></p>
<p>应用程序的信息、数据。如数据库的数据等都存放在此文件夹。</p>
<p><strong>/var/local</strong></p>
<p>/usr/local中程序的信息、数据</p>
<p><strong>/var/lock</strong></p>
<p>锁文件</p>
<p><strong>/var/log</strong></p>
<p>日志文件</p>
<p><strong>/var/opt</strong></p>
<p>/opt中程序的信息、数据</p>
<p><strong>/var/run</strong></p>
<p>正在执行着的程序的信息，如PID文件应存放于此</p>
<p><strong>/var/spool</strong></p>
<p>存放程序的假脱机数据（即spool data）</p>
<p><strong>/var/tmp</strong></p>
<p>临时文件</p>
<h2 id="-">参考资料</h2>
<ul>
<li><a href="http://www.pathname.com/fhs/" target="_blank">FHS网站</a></li>
<li><a href="TLDP: Linux Filesystem Hierarchy">TLDP: Linux Filesystem Hierarchy</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-06-23T06:05:00.000Z"><a href="/2012/06/my-faile-can-be-copied/">Jun 23 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/06/my-faile-can-be-copied/">我的失败可以复制</a></h1>
  

    </header>
    <div class="entry">
      
        <p>常听人说，如果你开始回忆过去，说明你老了。而我却时常会怀念过去，或者说，是忏悔。</p>
<p>有时候会想，如果大学的前三年可以重新来过，让我们都回到那个懵懂的年纪，重新开始全新的大学生活，一定会选择一种完全不一样的生活。我一直以为，世界上有另外一个我，在过着我想过的生活，在做着我想做的事，而我却永远无法重新选择。</p>
<p>永远不能回头，在不断的选择中，我们创造了自己的生活。然而，当我们回首时看到的却满是错误与失去，多想穿越时空告诉那时的自己，你的选择，错了。可是，这些都是没有用的，回不去的事情再勉强也是幻想，走好余下的路才是最重要的，过去的错误永远是最宝贵的财富。</p>
<p>生命中，我们竭尽全力都无法改变的事情：倒向你的墙，离你而去的人，流逝的时间，和永远的过去。</p>
<p>就像这句歌词一样：“如果骄傲没被现实大海冷冷拍下，又怎会懂得要多努力才走得到远方；如果梦想不曾坠落悬崖千钧一发，又怎会晓得执着的人有隐形翅牓。”</p>
<p>所以，不要难过了。离过去越近，离未来就越远。过精彩的生活，遇到精彩的人，找到精彩的未来。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-06-06T04:52:47.000Z"><a href="/2012/06/my-ncee/">Jun 5 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/06/my-ncee/">我的高考</a></h1>
  

    </header>
    <div class="entry">
      
        <p>后天就要高考了，但这似乎已经与我无关。那段时光已经过去三年，可每每到这个时候，都会禁不住想起当年的我，当年的18班。</p>
<p>时间正在将过往一丝一丝地抹去，我想在淡忘之前，再次品味一下那年的生活。</p>
<p>关键字：运动场，角落，封闭的军事化管理，星空，考试那天</p>
<h3 id="-">运动场</h3>
<p>每天晚饭吃过以后，大约6点半，我们会三三两两到运动场上跑步，一般是跑6圈，然后满头大汗地回到教室等待晚自修。不管天气多么热，尤其是临近6月的时候，跑道上塑胶的味道很具有冲击感，但我们都依旧坚持着。当时的想法很简单，身体好才能保证学习，而要想身体好就要锻炼。那时候跟我一起跑的通常是永明，我高三时的同桌，物理超牛逼的一个人，现在在北大学物理系。跑步完之后，有时候我们会坐在草坪上，望着天空，莫名地感叹一下高三的生活，憧憬一下美好的未来，讨论一下大学，讨论一下理想。那时候没有多余的想法，黑色的高三也没那么苦，只是觉得很充实，很带感。</p>
<h3 id="-">角落</h3>
<p>后来，我们在教室的位置换成了桌子和桌子相互隔开的布局，谁也不是谁的同桌。我特别向往教室最后面的角落里的那个座位，或许只是想求得一份宁静，在聒噪的高三里，能有一片属于自己的瓦尔登湖。</p>
<p>再后来，我后面的位置成了兴华的山水宝地。6月初即将高考的时候，我们还会在角落里说一些不着边的话题，整晚整晚地讨论。晚间下课，这个角落会是一帮人的美食之地，食堂买来的烧饼、馒头，超市买来的虾皮、老干妈，偶尔还会有一些新奇的玩意儿，大家热闹地讨论着，玩笑着。</p>
<h3 id="-">封闭的军事化管理</h3>
<p>我们学校向河北的衡中学习，实行封闭式的军事化管理，加上我们竞争压力比较大，每个人都拼命地学习。你永远无法体会高考面对98万考生同省竞争的压力，同样的大学，对于我们的分数会高出很多。每天五点半就要起床，一直到晚上十点半，紧张、规律的生活按照预定的轨道有条不紊。</p>
<p>不过我却很感谢这样的生活，磨练了那个时候的我们。就像永明走路一样，只有加快步伐，才能缩短浪费在路途中的时间。如今，永明走路的步伐依旧是那么快，我总也赶不上。</p>
<h3 id="-">星空</h3>
<p>冬天的时候，每天5点半起床，走在去教室的路上，总会抬头找北斗七星的形状。清晨的感觉，就是夜的感觉；夜的感觉，就是努力的感觉。</p>
<p>清晨的夜，还有停车棚的自行车，留给我了永远无法磨灭的记忆。只要抬头仰望星空，就好像回到了那个时候，再来一首周杰伦的《简单爱》，我会觉得是时光倒流。</p>
<h3 id="-">考试那天</h3>
<p>靠！考试那天，我的嘴唇被蚊子咬了。听起来貌似很荒谬，但更荒谬的是，初中中考的那一天，我的嘴唇也被蚊子咬了。我一直觉得冥冥之中是谁在安排着，或许上辈子我与蚊子有仇吧，简直巧合的难以令人相信。而且，截至目前，我的嘴唇总共被蚊子咬过两次，就是这两次。</p>
<p>说实话，考试那两天记忆不太深，感觉跟平常一样。语文作文搞砸了，理综没感觉，数学还不错，英语还凑合。然后，考完英语的那天下午，我们不像其他人一样，而是来到了教室估分。随后，奋斗在批阅前线的老师们发来了参考答案，那几天便疯狂地选校、填志愿。那时侯谁知道，这一选，选的是自己整个青春。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-05-20T23:33:03.000Z"><a href="/2012/05/how-to-keep-alive-with-less-sleep/">May 20 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/05/how-to-keep-alive-with-less-sleep/">(转)如何在保证睡眠的情况下高效学习</a></h1>
  

    </header>
    <div class="entry">
      
        <p>来源：<a href="http://blog.renren.com/blog/230557688/844071536" target="_blank">http://blog.renren.com/blog/230557688/844071536</a></p>
<p>少睡不是长久之计，关键还是要高效地管理时间，提供十条高效做事的经验。</p>
<p>每天都过的很快，好像起床以后忙活几下，又到了晚上，很快又要睡觉了。To-do-list上的事好像总是做不完，有的时候积压地太多以至于都不想去碰了。每天从早到晚都是忙碌状态，但是总觉得做不了几件事，要是给我1天48小时该多好。</p>
<p>事情太多时间不够，但是睡少了又效率低下，这实在是个悖论。似乎很多牛人都可以睡的很少，每天4-5小时睡眠，或者间歇式的睡眠，就可以高效地做事。这个境界我总是达不到，也没有想去达到。少睡不是长久之计，关键还是要高效地管理时间。</p>
<p>我今天和一个朋友请教了这个问题，很受启发。我朋友是卡内基梅陇大学的计算机在读博士，发表了好几篇顶级论文，科研做的很牛。除学术以外，他还忙活不少其他的事，他是云飞跃留学平台的兼职编辑，他业余时间喜欢研究摄影，最近又在开发一款手机游戏，他周末也会花不少时间陪女朋友。尽管做那么多事，他告诉我说他每天都精力充沛，做事效率很高！</p>
<p>但是他每天可以睡8小时！</p>
<p>他讲了好几条高效做事的经验：</p>
<h3 id="1-">1、作息要规律，这是重中之重。</h3>
<p>他的作息大致是这样的：</p>
<p>6:00 起床和早餐</p>
<p>7:15 – 7:30 跑步到学校</p>
<p>7:30 – 8:15 健身</p>
<p>8:30 – 11:30 做事</p>
<p>11:30 – 13:00 午饭+午睡</p>
<p>13:00 – 18:00 做事</p>
<p>18:00 – 19:30 晚饭</p>
<p>19:30 – 22:30 做事</p>
<p>22:30 睡觉</p>
<p>所以每天约有11小时在做事。他说只有作息规律了，身体机能才能达到最大的发挥。就像生产线一样，只有流程化了，效率才能提高。作息经常不规律，身体就要不断调整，这个调整很消耗能量，影响效率。就像一个GPS，总是在re-calculating，还怎么指路呢？</p>
<h3 id="2-">2、不要熬夜，熬夜伤身。</h3>
<p>很多人觉得12点，1点睡觉没关系，只要习惯就行了，人的适应能力很好的。但是大量的医学研究表明，长期熬夜会引发很多病，而且这些病一旦爆发，往往后果很严重。我知道卡内基梅陇的人很能熬夜，刚来的时候我有几次半夜2点回家，等校车的有不少人。但后来我感觉这边的课程和科研压力很大，一直熬夜下去会一发不可收拾，我就强迫自己改变。改变前你要先明白一点：只要睡眠不减少，不管早睡晚睡，每天做事的时间实际是差不多的。</p>
<h3 id="3-">3、每天要有固定的时间锻炼，至少半小时。</h3>
<p>锻炼可以促进新城代谢，调节身体机能。每天经常锻炼的人，虽然消耗了体力，但是换来的是精神充沛，相反那些不锻炼的人，经常觉得累。</p>
<h3 id="4-">4、做事之前多想想。</h3>
<p>想明白你为什么做这件事，怎样做可以达到最佳的效果。很多人是拿起事情就做，兵来将挡水来土掩，一股脑的做完了事。这实际上是非常不明智而且低效的做法，因为目的不清晰就会走岔路，做事方法不优化就会浪费时间。有的时候你花5分钟多想想，可以节省你好几个小时。</p>
<h3 id="5-">5、做事不要拖。</h3>
<p>很多人喜欢拖，事情就不断积累下来了，然后被一个又一个的deadline折磨。重要的事情一定要在合适的时间尽快处理掉。一件事如果比较耗时，要做好规划，每天做一点。</p>
<h3 id="6-">6、每天要做的事尽量写下来，不要只是放在脑中。</h3>
<h3 id="7-">7、做事要专注。</h3>
<p>很多人做事的时候，开着renren、Facebook、weibo、QQ和其他网页，不时会去看看有什么新情况。你以为它们只会占居你很少的时间，其实这些时间碎片严重影响了你的效率。就像睡觉一样，你如果被断断续续的声音影响，你就没法进入深度睡眠。所以，做重要的事情的时候，把这些务必都关了，邮件也尽量定期去查看，免得经常被新来的邮件打断。</p>
<h3 id="8-">8、控制好做事的节奏，张弛有度。</h3>
<p>从早到晚做事不可能保持一样的效率，如果你早上精神好，那就在早上尽量做重要的事，下午和晚上做一些相对轻松的事。在1小时内做事，也要把握节奏，可以高强度地做50分钟，然后低强度的做10分钟或者休息。道理大家都懂，但很多人一忙起来就不能自拔了。</p>
<p>我再根据自己的经验补充2条吧：</p>
<h3 id="9-multi-task-task-task-">9、如果你喜欢multi-task（多任务处理），尽量减少task之间频繁切换，并且每个task的时间要控制好。</h3>
<p>我一般一小时内就做一个task，如果1小时到了，我通常就会换下一个（如果没有deadline限制）。长时间做一个task往往会效率低下。</p>
<h3 id="10-">10、知道什么事你能做，什么事你不能做。</h3>
<p>我们经常想做很多事，但是精力有限，能力有限，使得我们必须做出选择。有些事你如果做不好就尽量不要去接受去承诺。选择是一种智慧，有所放弃才能保证你的睡眠。</p>
<p>希望这些经验对你有帮助！</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-05-12T04:38:01.000Z"><a href="/2012/05/python-decorator/">May 11 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/05/python-decorator/">Python中的装饰器Decorator</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Stackoverflow上面有一个问题（<a href="http://stackoverflow.com/questions/739654/understanding-python-decorators" target="_blank">Here</a>），问题是这样的：</p>
<p>如果使用如下的代码：</p>
<pre><code>:::Python
@makebold
@makeitalic
def say():
    return &quot;Hello&quot;
</code></pre><p>打印出如下的输出：</p>
<pre><code>:::HTML
&lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;
</code></pre><p>你会怎么做？最后给出的答案是：</p>
<pre><code>:::Python
def makebold(fn):
    def wrapped():
        return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;
    return wrapped

def makeitalic(fn):
    def wrapped():
        return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;
    return wrapped

@makebold
@makeitalic
def hello():
    return &quot;hello world&quot;

print hello() ## 返回 &lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;
</code></pre><p>其中的@其实就是Python的装饰器。</p>
<p>装饰器模式可以在不影响其它对象的情况下，以动态、透明的方式给单个对象添加职责，也能够处理那些可以撤销的职责。经常用于日志记录、性能测试等场合。</p>
<p>想象一下这个很常见的场景，你写了一个方法只提供给以登陆的用户访问，你可以写以下代码：</p>
<pre><code>:::Python
def A():
    if user.is_login():
        do something
    else:
        pass
</code></pre><p>这当然没什么问题，但是你又写了一个方法B，也要求只有登录用户可以访问，于是有写了以下代码：</p>
<pre><code>:::Python
def B():
    if user.is_login():
        do something
    else:
        pass
</code></pre><p>问题出来了，如果不是两个方法而是一堆方法，你可能就有点受不了啦。当然聪明的你可以想出这个方法：</p>
<pre><code>:::Python
def A():
    pass
def B():
    pass
def login_required(fn):
    def ff():
        if user.is_login():
            fn()
        else:
            pass
    return ff

A = login_required(A)
B = login_required(B)
</code></pre><p>你可能没有想到，对于这么好用的东西，python优雅的支持，这就是@修饰符：</p>
<pre><code>:::Python
def login_required(fn):
    def ff():
        if user.is_login():
            fn()
        else:
            pass
    return ff

@login_required
def A():
    pass
@login_required
def B():
    pass
</code></pre><p><strong>在方法A上边写一个@修饰符，调用方法A的时候会调用修饰符后边的方法B，方法B以A方法为参数，而且需要返回一个可调用的对象，这个可调用的对象会使用A方法提供的参数执行。</strong>看这个例子：</p>
<pre><code>:::Python
#!/usr/bin/env python  

def a(fn):
    print &#39;a&#39;
    def d(st):
        print st+&#39;d&#39;
    return d

def b(fn):
    print &#39;b&#39;
    return fn

@a
@b
def c(st):
    print st

c(&#39;c&#39;)
</code></pre><p>输出结果是：bacd</p>
<p>我们调用c(&#39;c&#39;)的时候会先调用b(c)，b(c)打印字符&quot;b&quot;然后返回c，然后再调用a(c)，a(c)打印字符&quot;a&quot;，然后返回方法d，然后再执行d(&#39;c&#39;)，打印cd。</p>
<p>参考资料：<a href="http://blog.csdn.net/shangzhihaohao" target="_blank">http://blog.csdn.net/shangzhihaohao</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-05-11T04:11:29.000Z"><a href="/2012/05/my-recent-life-things/">May 10 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/05/my-recent-life-things/">近况 &amp; 忙里偷闲</a></h1>
  

    </header>
    <div class="entry">
      
        <p>我觉得有必要记录一下生活。</p>
<p>两年前，我对自己的生活就一个要求：“每天都要创造价值”。当时还和某某人深入探讨过，什么是价值，怎样去创造的问题。不知到某某人还记得否，当年为此想法兴高采烈，一致认为应该将其写本书，也像那谁谁一样火一把。后来遗憾的是，再也没有机会和某某人探讨这个问题了，只好躬身而行，久而久之，竟然也成了一种习惯性的思维。如果某天不能创造点价值（在自己看来），就没有勇气结束一天。不过毕竟人无完人，长期以来，这种思维导致的直接后果就是养成了晚睡的好习惯...看来必须调整一下了。</p>
<p>最近几天，除了迫在眉睫的TOEFL、GRE外，其它时间全部沉浸在Tornado中。想起以前的时候，阿北坐在星巴克，用四五个月的时间创造了豆瓣，我就有种莫名的冲动。但我创造的不是豆瓣，而是一个中国的关于Python的开源社区。细节就不透露了，PyPub.com，敬请期待。</p>
<p>其实我想吐槽一下Tornado，就不能有一个像样的文档吗！各种问题搞不清楚，查不到资料。还好Tornado是个轻量级的框架，还可以读一读源码找找问题。其实也是一举两得的事情，就像当我把Markdown的Python实现的源码过了一遍的时候，其语法也就了解的差不多了，也就是说，如果你把JAVA的C++源码读一遍，大抵也就可以用JAVA编程了（偷笑）。但一举两得的事往往要艰难得多，很多时候我们不愿意去做罢了。</p>
<p>最近比较有感触的一句话：“世界是一本书，没旅行过的人只看到其中一页。”比起中规中矩的生活，我更喜欢有挑战的生活，更喜欢新的气息，我想去阅读这本书，因为我们只有这一次生命来阅读它。阅尽人世繁华，何尝不是一种人生。因为如此，也许我不会过早地结婚，但我会从结婚的那一天起，带我的爱人环游世界。</p>
<p>嗯，忙里偷闲，简简单单寥寥数语，共勉青春年华。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-05-03T15:28:03.000Z"><a href="/2012/05/seven-habits-of-hight-effective-people/">May 3 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/05/seven-habits-of-hight-effective-people/">高效人士的七种习惯（中英对照）</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>摘要：</strong></p>
<p>Habit 1: Be Proactive 凡事积极主动</p>
<p>Habit 2: Begin with the End in Mind 先定目标而后有行动</p>
<p>Habit 3: Put First Things First 重要的事要先做</p>
<p>Habit 4: Think Win-Win 为了大家都赢</p>
<p>Habit 5: Seek First to Understand, Then to Be Understood 先理解别人，再让别人理解自己</p>
<p>Habit 6: Synergize 协同合作</p>
<p>Habit 7: Sharpen the Saw 磨亮锯子（意指不断自我提高）</p>
<p><strong>全文：</strong></p>
<p>高效人士的七种习惯</p>
<p>斯蒂芬·科卫教授（Prof. Stephen Covey）</p>
<p>Our character is a composite of our habits. Changing habits is hard, but can be done by tremendous commitment. A (good) habit can be defined as the intersection of knowledge, skill and desire. Change is a cycle of being and seeing (visualization).</p>
<p>Our objective is to move progressively on a maturity continuum from dependence to independence to interdependence. Although independence is the current paradigm of our society, we can accomplish much more by cooperation and specialization. However, we must achieve independence before we can choose interdependence.</p>
<p>我们的性格是我们的习惯的集合物。改变习惯是困难的，但只要下定特大的决心，习惯是可以改变的。一种（良好）习惯可以被定义为知识、技能和愿望的交汇点。改变即是存在和视觉的循环。</p>
<p>我们的目标是，从依赖到独立、再到互相依赖，在成熟连续流中循序渐进。虽然独立是当前我们的社会模式，但是我们通过合作和专业化却可以取得更多的成绩。尽管如此，在能够选择相互依赖之前，我们必须取得独立。</p>
<h3 id="habit-1-be-proactive-">Habit 1: Be Proactive 凡事积极主动</h3>
<p>The first and most basic habit of a highly effective person in any environment is the habit of proactivity. Being proactive means that as human beings, we are responsible for our own lives. Our behavior is a function of our decisions, not our conditions. We can subordinate feelings to values. We have the initiative and the responsibility to make things happen.</p>
<p>Look at the word responsibility-response-ability-the ability to choose your responses. Highly proactive people recognize that responsibility. They do not blame circumstances, conditions, or conditioning for their behavior. Their behavior is a product of their own conscious choice, based on values, rather than a product of their conditions, based on feeling. The opposite of proactive is reactive. The spirit of reactive people is the transfer of responsibility. Their language absolves them of responsibility.</p>
<p>Proactive people focus their time and energy on their Circle of Influence (things they can control) in lieu of reacting to or worrying about conditions over which they have little or no control (Circle of Concern). In so doing,proactive people use positive energy to influence conditions and increase their Circle of Influence.</p>
<p>在任何环境中做事效率很高的人都具有的首要以及基本的习惯是积极主动的习惯。积极主动的含义是，我们作为人类，应该对我们自己的生命负责。我们的行为不是环境而是我们做出的决定的结果。我们可以使感觉服从价值。我们有创造的主动性和责任性。</p>
<p>看看responsibility（责任）这个词，它由response（反应）和ability（能力）两个词组成，意思是选择做出反应的能力。非常积极主动的人认识到这种责任。他们不抱怨环境、条件或者环境对他们的驯化作用。他们的行为是他们自己基于价值而有意做出选择的一种产物，而不是基于感情的、他们的条件的产物。积极主动的反义词是消极被动。消极被动者的精神是逃避责任，他们的言辞为自己开脱责任。</p>
<p>积极主动的人将自己的时间和精力集中在自己的“势力范围”（自己可以控制的事物）之内，而不是对自己几乎不能或完全不能控制的条件（“关注范围”）做出被动的反应或担心。</p>
<h3 id="habit-2-begin-with-the-end-in-mind-">Habit 2: Begin with the End in Mind 先定目标而后有行动</h3>
<p>To begin with the end in mind means to begin each day with a clear understanding of your desired direction and destination. By keeping that end in mind you can make certain that whatever you do on any particular day does not violate the criteria you have defined as supremely important, and that each day of your life contributes in a meaningful way to the vision you have of your life as a whole.</p>
<p>Begin with the end in mind is based on the principle that all things are created twice. There’s a mental or first creation and a physical or second creation. The second, or physical creation, follows from the first, just as a building follows from a blueprint. In our personal lives, if we do not develop our own self-awareness and become responsible for first creations, we empower other people and circumstances to shape our lives by default.</p>
<p>Leadership is the first creation. Management is the second creation. Management is a bottom line focus: How can I best accomplish certain things? Leadership deals with the top line: What are the things I want to accomplish? In the words of both Peter Drucker and Warren Bennis, “Management is doing things right; leadership is doing the right things.” Management is efficiency in climbing the ladder of success; leadership determines whether the ladder is leaning against the right wall.</p>
<p>先有目标而后有行动，意思是每一天开始时，你都清楚地了解自己想要实现的方向或目标。当你心怀目标，你才能做到每一个具体的日子所做的任何事情都不违反你已经确定的极其重要的标准，你生活中的每一天都在以一种积极的方式有助于达到你整个人生的愿景。</p>
<p>“先有目标而后有行动”是建立在这样一种原理基础上的，即所有事情都经历两次创造。第一种是精神创造，第二种是物质创造。第二种或物质创造产生于第一种创造，正如先有蓝图再盖房子一样。在我们的个人生活中，如果我们不开发自我意识，不对第一种创造负责，我们就会让别人和环境错误地改变我们的人生。</p>
<p>领导是第一种创造，管理是第二种创造。管理关注基层工作：我怎样能够完成某些事情？领导处理高层事务：那些事情是我想要完成的？用德鲁克和本尼斯两人的话，就是：”管理是把事情做得正确，领导是做正确的事情。”管理是在成功阶梯上攀登的效率，领导是确定是否把梯子放到了正确的墙上。</p>
<h3 id="habit-3-put-first-things-first-">Habit 3: Put First Things First 重要的事要先做</h3>
<p>What are first things? First things are those things that you, personally, find most worth doing. They move you in the right direction and help you achieve the purpose expressed in your mission statement.</p>
<p>Put First Things First involves organizing and managing time and events according to the personal priorities established in Habit 2 (Begin with the End in Mind). Habit 2 is the first or mental creation. Habit 3, then, is the second, or physical creation. It’s the day-in, day-out, moment by moment doing it.</p>
<p>哪些事是重要的事情？重要的事情就是那些你自己发现最值得做的事情。它们使你沿着正确的方向前进，帮助你达到你在个人使命里陈述的目标。</p>
<p>“重要的事要先做”牵涉到根据习惯二（“先有目标而后有行动”）里所建立的个人优先事项对时间、事件进行组织和管理。习惯二是第一种或精神创造，而习惯三是第二种或物质创造。它是日进日出、每时每刻地做事。</p>
<h3 id="habit-4-think-win-win-">Habit 4: Think Win-Win 为了大家都赢</h3>
<p>In relationships and businesses, effectiveness is largely achieved through the cooperative efforts of two or more people. Marriages and other partnerships are interdependent realities, and yet people often approach these relationships with an
independent mentality, which is like trying to play golf with a tennis racket-the tool isn’t suited to the sport.</p>
<p>Most of us learn to base our self-worth on comparisons and competition. We think about succeeding in terms of someone else failing. That is, if I win, you lose. Or if you win, I lose. There is only so much pie and if you get a big piece there is less for me. People with this type of Scarcity Mentality find it difficult to share recognition and power, and to be happy for the successes of others, especially those closest to them.</p>
<p>Win-Win, on the other hand, is based on the paradigm that there is plenty for everybody, that one person’s success is not achieved at the expense or exclusion of the success of others. Win-Win sees life as a cooperative, not a competitive arena. Win-Win is a frame of mind and heart that constantly seeks mutual benefit in all human interactions. Win-Win means that agreements or solutions are mutually beneficial and satisfying.</p>
<p>在社会关系和商务活动中，效率大体上都要经过两个或两个以上的人的合作努力才能取得。婚姻和其他伙伴关系是互相依赖的现实，然而人们却经常以一种独立的心态处理这些关系，如同用网球拍去打高尔夫球——使用了不适合这种体育运动的工具。</p>
<p>我们中的多数人学会了将自我价值建立在比较和竞争之上。我们想着在别人摔倒时进行超越。这就是说，如果我赢，就是你输。或者，如果你赢，就是我输。馅饼就这么大，如果你得到一大块，我得到的就要少。怀有这种”稀缺心态”的人很难与人分享赞誉与权力，很难为别人特别是天天跟自己在一起的人获得成功而感到高兴。</p>
<p>在另一方面，“双赢”或“大家都赢”是建立在每个人都有许多机会这个思想方式上的，即一个人并不是以牺牲别人利益或排除别人成功而取得成功。“大家都赢”把人生看作是合作而不是竞争的舞台。“大家都赢”是在所有人类共处中不断需求相互利益的一种心灵结构。“大家都赢”意味着各种约定和方案对于大家都是有益处而且是使大家都满意的。</p>
<h3 id="habit-5-seek-first-to-understand-then-to-be-understood-">Habit 5: Seek First to Understand, Then to Be Understood 先理解别人，再让别人理解自己</h3>
<p>Communication is the most important skill in life. We spend most of our waking hours communicating. But consider this: You’ve spent years learning how to read and write. Years learning how to speak. But what about listening? What training or education have you had that enables you to listen so that you really, deeply understand another human being from that individuals’ own frame of reference?</p>
<p>Seeking first to understand, or diagnosing before you prescribe, is a correct principle manifest in many areas of life. A wise doctor will diagnose before writing a prescription. A good engineer will understand the forces, the stresses at work, before designing the bridge. An effective salesperson first seeks to understand the needs of the customer before offering a product. Similarly, an effective communicator will first seek to understand another’s views before seeking to be understood.</p>
<p>Until people feel properly diagnosed they will not be open to prescriptions. We typically seek first to be understood. Most people do not listen with the intent to understand; they listen with the intent to reply. They’re either speaking or preparing to speak. They’re filtering everything through their own paradigms,reading their autobiography into other people’s lives.</p>
<p>沟通是人生最为重要的技能，我们将醒着的大部分时间用来沟通。但是，你要考虑这个问题：你花了许多年时间读书、认字、说话，但是学习聆听了吗？你所接受过的教育或培训，有没有课程使你能够通过聆听从而站在另一个人的角度去真正深刻地理解他？</p>
<p>寻求先理解别人，或者是先诊断再开方，是人生许多领域正确的原则妙方。明智的大夫在开方之前先诊断。出色的工程师在设计桥梁之前先要理解力学和运营应力。有效率的销售员在推荐一种产品之前首先要寻求理解客户的需要。同样，有效率的沟通者在寻求别人理解自己之前，先要寻求理解别人的观点。人们只有在感到得到了恰当的诊断之后才会愿意接受处方。</p>
<p>我们通常是首先要别人理解自己。大多数人不是怀着理解别人的意图去聆听，他们聆听的意图是要别人做出回答。他们要么是说话，要么是准备说话。他们用自己的模式过滤一切，以自己的经历来理解别人的生活。</p>
<h3 id="habit-6-synergize-">Habit 6: Synergize 协同合作</h3>
<p>Synergy is everywhere in nature. The intermingled roots of two plants growing closely together improve the quality of the soil. Two pieces of wood bonded together hold much more than the total of the weight held by each separately. The whole is
greater than the sum of its parts. One plus one equals three or more.</p>
<p>The principle of synergy also holds true in social interactions. Two people, creatively cooperating, will be able to produce far better results than either one could alone. Synergy lets us discover jointly things that we are much less likely todiscover by ourselves. It occurs when minds stimulate each other and ideas call forth ideas. I say something that stimulates your mind; you respond with an idea that stimulates mine. I share that new idea with you, and the process repeats itself andeven builds.</p>
<p>Synergy works. It is the crowning achievement of all the previous habits. It is effectiveness in an interdependent reality-it is teamwork, team building, the development of unity and creativity with other human beings.</p>
<p>Valuing the differences is the essence of synergy-the mental, the emotional, the physiological differences between people. And the key to valuing those differences is to realize that all people see the world, not as it is, but as they are. When we value differences and bring different perspectives together in the spirit of mutual respect, people then feel free to seek the best possible alternative, often the Third Alternative, one that is substantially better than either of the original proposals. Finding a third alternative is not compromise, but represents a Win-win solution for both parties.</p>
<p>协同是自然界的普遍现象。依偎在一起生长的两种植物的根交织在一起，能够改良土壤的质量。两根木棍绑在一起所承受的分量要比单独一根所承受的分量大得多。整体大于部件之和。一加一等于三甚至更多。</p>
<p>协同原理在社会互动中也是真理。进行创造性合作的两个人所创造的成果，比两人中任何一个人单独去做要多得多。协同让我们共同发现我们个人所较少发现的东西。当主意相互碰撞、想法相互启发，协同效应就发生了。我说的事情激发你的想法，你回应的主意又对我有所启发。我与你分享一个新的主意，而这个过程不断重复，甚至有所建树。</p>
<p>协同合作是有效的，它是在前面所有习惯基础上取得的成绩。它是存在于一种相互依赖的现实之中的效率——是团队工作，是团队建设，是与别人团结创造的发展。</p>
<p>重视差异——人们在智力、情感、心理上的差异——是协同合作的精髓。重视差异的关键是，承认人们不是以客观存在而是以自己的认识去看待世界。当我们重视分歧，根据相互尊重的精神把不同的观点带到一起，那么大家就能够自由地寻求可能的最佳方案，通常是“第三种方案”。这种方案事实上要比原有的任何一种提议都要好。找到一个第三种方案并不是妥协，而它是代表了能使双方皆赢的答案。</p>
<h3 id="habit-7-sharpen-the-saw-">Habit 7: Sharpen the Saw 磨亮锯子</h3>
<p>Habit 7 is the habit that makes all the others possible. Sharpen the Saw means preserving and enhancing the greatest asset you have-you. It means having a balanced, systematic program for self-renewal in the four areas of our lives: physical, mental, emotional-social, and spiritual. Without this discipline, the body becomes weak, the mind mechanical, the emotions raw, the spirit insensitive, and the person selfish.</p>
<p>This is the single most powerful investment we can ever make in life-investment in ourselves, in the only instrument we have with which to deal with life and to contribute. Yet when people get busy producing, or sawing, they seldom take time to Sharpen the Saw because maintenance seldom pays dramatic, immediate dividends.</p>
<p>This daily Private Victory is the key to the development of the Seven Habits, and it’s completely within our control. Renewal is the principle and the process that empowers us to move on an upward spiral of growth and change, of continuous improvement.</p>
<p>习惯七是使所有其它习惯变得可能的习惯。“磨亮锯子”意思是保存并增强你所拥有的最大资产——你。这个意思就是，在人生的四个领域——身体、智力、情感或社会、精神——制定一个平衡的、系统的自我提高计划。没有这么一条，身体将会变得虚弱，心灵将会变得死板，情感将会变得呆滞，精神将会变得迟钝，人将会变得自私。</p>
<p>这是我们在生活中最能够进行的单一最有效果的投资——对我们自己、对我们所拥有的唯一工具进行投资。有了它，我们便可应对生活、做出贡献。</p>
<p>这种每天都能有的“个人胜利”是开发七种习惯的关键，而且它是完全能够被我们自己所控制的。自我提高是这样一种法则和过程，它使我们能够象螺旋那样向上成长和变化，经历持续不断的改善。</p>
<p><em>来源：网络</em></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-04-30T00:03:08.000Z"><a href="/2012/04/new-hybi-10-protocol-of-websocket/">Apr 29 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/04/new-hybi-10-protocol-of-websocket/">WebSocket新版Hybi-10协议介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <p>不知道问什么，网上的几乎所有关于WebSocket的讲解都是旧版协议，开源的PHP-WebSocket也早不更新了。一开始还以为是服务器程序的原因，后来发现是协议变更了。而且好不容易将握手协议更换为新版后，发现传送的数据都是乱码（见<a href="http://weibo.com/1784705505/ygyi4A0Pj" target="_blank">这里</a>），原来数据报文的格式也进行了非常大的变更！</p>
<p>之前我们曾介绍过基于WebSocket协议的服务器实现，但那篇文章中提到的WebSocket协议标准还是草案7.5、7.6的标准，如今只有Safari支持此版本的协议，Chrome和Firefox最新版都已升级至Hybi-10（<a href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10" target="_blank">协议地址</a>）。因此，我们再来介绍一下WebSocket新版协议Hybi-10。这次协议变更非常大，主要集中在握手协议和数据传输的格式上。下面我们来详细介绍一下。</p>
<h3 id="-">握手协议</h3>
<p>我们先来看一下大致的区别：</p>
<ol>
<li>最老的websocket草案标准中是没有安全key，草案7.5、7.6中有两个安全key，而现在的草案10中只有一个安全key，即将7.5、7.6中http头中的&quot;Sec-WebSocket-Key1&quot;与&quot;Sec-WebSocket-Key2&quot;合并为了一个&quot;Sec-WebSocket-Key&quot;</li>
</ol>
<ol>
<li>把http头中Upgrade的值由&quot;WebSocket&quot;修改为了&quot;websocket&quot;；http头中的&quot;-Origin&quot;修改为了&quot;Sec-WebSocket-Origin&quot;;</li>
</ol>
<ol>
<li>增加了http头&quot;Sec-WebSocket-Accept&quot;，用来返回原来草案7.5、7.6服务器返回给客户端的握手验证，原来是以内容的形式返回，现在是放到了http头中；另外服务器返回客户端的验证方式也有变化。</li>
</ol>
<p>服务器生成验证的方式变化较大，我们来做一介绍。</p>
<p>旧版：</p>
<pre><code>GET / HTTP/1.1
Upgrade: WebSocket
Connection: Upgrade
Host: 127.0.0.1:1337
Origin: http://127.0.0.1:8000
Cookie: sessionid=xxxx; calView=day; dayCurrentDate=1314288000000
Sec-WebSocket-Key1: cV`p1* 42#7  ^9}_ 647  08{
Sec-WebSocket-Key2: O8 415 8x37R A8   4
;&quot;######
</code></pre><p>旧版生成Token的方法如下：</p>
<p>取出Sec-WebSocket-Key1中的所有数字字符形成一个数值，这里是1427964708，然后除以Key1中的空格数目，得到一个数值，保留该数值整数位，得到数值N1；对Sec-WebSocket-Key2采取同样的算法，得到第二个整数N2；把N1和N2按照Big-Endian字符序列连接起来，然后再与另外一个Key3连接，得到一个原始序列ser_key。Key3是指在握手请求最后，有一个8字节的奇怪的字符串“;”######”，这个就是Key3。然后对ser_key进行一次md5运算得出一个16字节长的digest，这就是老版本协议需要的token，然后将这个token附在握手消息的最后发送回Client，即可完成握手。</p>
<p>新版：</p>
<pre><code>GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: 127.0.0.1:1337
Sec-WebSocket-Origin: http://127.0.0.1:8000
Sec-WebSocket-Key: erWJbDVAlYnHvHNulgrW8Q==
Sec-WebSocket-Version: 8
Cookie: csrftoken=xxxxxx; sessionid=xxxxx
</code></pre><p>新版生成Token的方法如下：</p>
<p>首先服务器将key（长度24）截取出来，如4tAjitqO9So2Wu8lkrsq3w==，用它和自定义的一个字符串（长度36）258EAFA5-E914-47DA-95CA-C5AB0DC85B11连接起来，然后把这一字符串进行SHA-1算法加密，得到长度为20字节的二进制数据，再将这些数据经过Base64编码，最终得到服务端的密钥，也就是ser_key。服务器将ser_key附在返回值Sec-WebSocket-Accept后，至此握手成功。</p>
<h3 id="-">数据报文格式</h3>
<p>旧版协议比较简单，仅仅是在原始数据前加了个’\x00′，在最后面加了个’\xFF’，即假如Client发送一个字符串’test’，实际上WebSocket Server收到的数据是：’x00test\xFF’，所以只需要剥离掉首尾那两个字符就可以了。</p>
<p>新版的协议对这部分规定比较复杂，以下是其格式标准：（下图在Firefox可能会出现错乱，请换用Chrome）</p>
<pre><code>      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
</code></pre><p><strong>FIN：</strong>1位，用来表明这是一个消息的最后的消息片断，当然第一个消息片断也可能是最后的一个消息片断；</p>
<p><strong>RSV1, RSV2, RSV3:</strong> 分别都是1位，如果双方之间没有约定自定义协议，那么这几位的值都必须为0,否则必须断掉WebSocket连接；</p>
<p><strong>Opcode:</strong>4位操作码，定义有效负载数据，如果收到了一个未知的操作码，连接也必须断掉，以下是定义的操作码：</p>
<ul>
<li>%x0 表示连续消息片断</li>
</ul>
<ul>
<li>%x1 表示文本消息片断</li>
</ul>
<ul>
<li>%x2 表未二进制消息片断</li>
</ul>
<ul>
<li>%x3-7 为将来的非控制消息片断保留的操作码</li>
</ul>
<ul>
<li>%x8 表示连接关闭</li>
</ul>
<ul>
<li>%x9 表示心跳检查的ping</li>
</ul>
<ul>
<li>%xA 表示心跳检查的pong</li>
</ul>
<ul>
<li>%xB-F 为将来的控制消息片断的保留操作码</li>
</ul>
<p><strong>Mask:</strong>1位，定义传输的数据是否有加掩码,如果设置为1,掩码键必须放在masking-key区域，客户端发送给服务端的所有消息，此位的值都是1；</p>
<p><strong>Payload length: </strong>传输数据的长度，以字节的形式表示：7位、7+16位、或者7+64位。如果这个值以字节表示是0-125这个范围，那这个值就表示传输数据的长度；如果这个值是126，则随后的两个字节表示的是一个16进制无符号数，用来表示传输数据的长度；如果这个值是127,则随后的是8个字节表示的一个64位无符合数，这个数用来表示传输数据的长度。多字节长度的数量是以网络字节的顺序表示。负载数据的长度为扩展数据及应用数据之和，扩展数据的长度可能为0,因而此时负载数据的长度就为应用数据的长度。</p>
<p><strong>Masking-key:</strong>0或4个字节，客户端发送给服务端的数据，都是通过内嵌的一个32位值作为掩码的；掩码键只有在掩码位设置为1的时候存在。
<strong>Payload data: </strong> (x+y)位，负载数据为扩展数据及应用数据长度之和。
<strong>Extension data:</strong>x位，如果客户端与服务端之间没有特殊约定，那么扩展数据的长度始终为0，任何的扩展都必须指定扩展数据的长度，或者长度的计算方式，以及在握手时如何确定正确的握手方式。如果存在扩展数据，则扩展数据就会包括在负载数据的长度之内。
<strong>Application data:</strong>y位，任意的应用数据，放在扩展数据之后，应用数据的长度=负载数据的长度-扩展数据的长度。</p>
<p>以下是Python实现的解码和编码，兼容新旧版协议，仅供参考：</p>
<pre><code>:::Python
def send_data(self, raw_str):
    if self.sockets[self][&#39;new_version&#39;]:
        back_str = []
        back_str.append(&#39;\x81&#39;)
        data_length = len(raw_str)

        if data_length &lt;= 125:
            back_str.append(chr(data_length))
        else:
            back_str.append(chr(126))
            back_str.append(chr(data_length &gt;&gt; 8))
            back_str.append(chr(data_length &amp; 0xFF))

        back_str = &quot;&quot;.join(back_str) + raw_str
        self.transport.write(back_str)
    else:
        back_str = &#39;\x00%s\xFF&#39; % (raw_str)
        self.transport.write(back_str)

def parse_recv_data(self, msg):
    raw_str = &#39;&#39;

    if self.sockets[self][&#39;new_version&#39;]:
        code_length = ord(msg[1]) &amp; 127

        if code_length == 126:
            masks = msg[4:8]
            data = msg[8:]
        elif code_length == 127:
            masks = msg[10:14]
            data = msg[14:]
        else:
            masks = msg[2:6]
            data = msg[6:]

        i = 0
        for d in data:
            raw_str += chr(ord(d) ^ ord(masks[i%4]))
            i += 1
    else:
        raw_str = msg.split(&quot;\xFF&quot;)[0][1:]

    return raw_str
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-04-17T05:46:21.000Z"><a href="/2012/04/socket-programming-in-php/">Apr 17 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/04/socket-programming-in-php/">PHP中的Socket编程</a></h1>
  

    </header>
    <div class="entry">
      
        <p>关于PHP socket的资料网上着实不多，或者讲的都不是很全面。为了更好地用PHP来处理socket，天堂皓月博客特地来简单总结一下其用法，尽量会做到深入浅出：）</p>
<h3 id="-">文章结构：</h3>
<ul>
<li>Socket基础知识</li>
</ul>
<ul>
<li>编写服务器</li>
</ul>
<ul>
<li>编写客户端</li>
</ul>
<ul>
<li>总结</li>
</ul>
<p>通过这三部分你将会体验到Socket的魅力，并了解怎样去编写一个服务器，怎样通过Sockets连接到服务器，服务器怎样处理信息并将信息发送给相应的客户端。</p>
<p>不管你信不信，只要你用过PHP，就一定用过Sockets。HTTP服务器就是一个Socket服务器，浏览器就是客户端，也就是最简单的C/S模式。</p>
<h3 id="socket-">Socket基础知识</h3>
<p>我们可以把Socket当做是一种数据结构，客户端和服务器间通过这种数据结构来交换数据。服务器开始监听连接，当客户端想要连接服务器时，会通过服务器监听的端口开启一个会话，服务器收到客户端的请求后，建立连接完毕，然后继续监听下一次连接。</p>
<p>要产生一个Socket，你我们需要三个变量：一个协议（protocol）、一个socket类型（socket type）和一个公共协议类型（common protocol type）。下面将会详细介绍各个部分的具体内容。</p>
<p><strong>协议</strong></p>
<ul>
<li>AF_INET：这是大多数用来产生socket的协议，使用TCP或UDP来传输，用在IPv4的地址</li>
</ul>
<ul>
<li>AF_INET6：与上面类似，不过是来用在IPv6的地址</li>
</ul>
<ul>
<li>AF_UNIX：本地协议，使用在Unix和Linux系统上，它很少使用，一般都是当客户端和服务器在同一台及其上的时候使用</li>
</ul>
<p><strong>Socket类型</strong></p>
<ul>
<li>SOCK_STREAM：这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</li>
</ul>
<ul>
<li>SOCK_DGRAM：这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</li>
</ul>
<ul>
<li>SOCK_SEQPACKET：这个协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</li>
</ul>
<ul>
<li>SOCK_RAW：这个socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</li>
</ul>
<ul>
<li>SOCK_RDM：这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</li>
</ul>
<p><strong>公共协议</strong></p>
<ul>
<li>ICMP：互联网控制消息协议，主要使用在网关和主机上，用来检查网络状况和报告错误信息</li>
</ul>
<ul>
<li>UDP：用户数据报文协议，它是一个无连接，不可靠的传输协议</li>
</ul>
<ul>
<li>TCP：传输控制协议，这是一个使用最多的可靠的公共协议，它能保证数据包能够到达接受者那儿，如果在传输过程中发生错误，那么它将重新发送出错数据包。</li>
</ul>
<p>在PHP中我们使用socket_create()函数来产生一个Socket。socket_create()函数运行成功返回一个包含Socket的资源类型，如果没有成功则返回false。</p>
<p>1 resource socket_create(int protocol, int socketType, int commonProtocol);</p>
<p>PHP提供了很多操作Socket的函数。现在我们来看一个例子，了解PHP是如何产生、接受和监听一个socket。</p>
<pre><code>:::PHP
&lt;?php
$commonProtocol = getprotobyname(“tcp”);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, ‘localhost’, 1337);
socket_listen($socket);
// More socket functionality to come
?&gt;
</code></pre><p>我们来详细解释一下上面这个程序（基于行号）：</p>
<p>第二行：使用公共协议名字来获取一个协议类型。在这里使用的是TCP公共协议，如果你想使用UDP或者ICMP协议，就应该把getprotobyname()函数的参数改为“udp”或“icmp”。我们也可以不使用getprotobyname()函数而是直接指定SOL_TCP或SOL_UDP。</p>
<p>第三行：产生一个Socket并且返回一个Socket资源的实例。</p>
<p>第四行：有了一个Socket资源的实例以后，就必须把Socket绑定到一个IP地址和某一端口上。在这里绑定socket到本地计算机（127.0.0.1）的1337端口。</p>
<p>第五行：然后就需要监听所有进来的socket连接。</p>
<p>这时，我们就需要了解一下PHP中Socket函数的使用方法了。官方手册的介绍非常不错（<a href="http://www.php.net/manual/en/ref.sockets.php" target="_blank">猛戳这个链接</a>），下面只是简单列举几个最常用的。</p>
<ul>
<li>socket_accept() 接受一个Socket连接</li>
</ul>
<ul>
<li>socket_bind() 把socket绑定在一个IP地址和端口上</li>
</ul>
<ul>
<li>socket_close() 关闭一个socket资源</li>
</ul>
<ul>
<li>socket_connect() 开始一个socket连接</li>
</ul>
<ul>
<li>socket_create_listen() 在指定端口打开一个socket监听</li>
</ul>
<ul>
<li>socket_create() 产生一个socket，相当于产生一个socket的数据结构</li>
</ul>
<ul>
<li>socket_get_option() 获取socket选项</li>
</ul>
<ul>
<li>socket_getpeername() 获取远程主机的ip地址</li>
</ul>
<ul>
<li>socket_getsockname() 获取本地socket的ip地址</li>
</ul>
<ul>
<li>socket_listen() 监听由指定socket的所有连接</li>
</ul>
<ul>
<li>socket_read() 读取指定长度的数据</li>
</ul>
<ul>
<li>socket_readv() 读取从分散/聚合数组过来的数据</li>
</ul>
<ul>
<li>socket_recv() 从socket里结束数据到缓存</li>
</ul>
<ul>
<li>socket_recvfrom() 接受数据从指定的socket，如果没有指定则默认当前socket</li>
</ul>
<ul>
<li>socket_recvmsg() 从iovec里接受消息</li>
</ul>
<ul>
<li>socket_select() 多路选择</li>
</ul>
<ul>
<li>socket_send() 这个函数发送数据到已连接的socket</li>
</ul>
<ul>
<li>socket_sendmsg() 发送消息到socket</li>
</ul>
<ul>
<li>socket_sendto() 发送消息到指定地址的socket</li>
</ul>
<ul>
<li>socket_set_block() 在socket里设置为块模式</li>
</ul>
<ul>
<li>socket_set_nonblock() socket里设置为非块模式</li>
</ul>
<ul>
<li>socket_set_option() 设置socket选项</li>
</ul>
<ul>
<li>socket_shutdown() 这个函数允许你关闭读、写、或者指定的socket</li>
</ul>
<ul>
<li>socket_write() 写数据到socket缓存</li>
</ul>
<p>关于PHP Socket的基础知识就介绍到这里，还有不明白的可查看官方手册。下面介绍编写一个Socket服务器。</p>
<h3 id="-">编写服务器</h3>
<p>现在我们把第一个例子完善，使其能够监听一个指定的Socket并处理用户的连接。</p>
<pre><code>:::PHP
&lt;?php
$commonProtocol = getprotobyname(&quot;tcp&quot;);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, &#39;localhost&#39;, 1337);
socket_listen($socket);
// Accept any incoming connections to the server
$connection = socket_accept($socket);
if($connection)
{
   socket_write($connection, &quot;You have connected to the socket...\n\r&quot;);
}
?&gt;
</code></pre><p>注意这不是一个Web页面，如果你尝试使用Web浏览器来运行这个脚本，那么很有可能它会超过PHP运行30秒的限时。当然你可以使用下面的代码来设置一个无限的运行时间</p>
<blockquote>
<p>set_time_limit(0);</p>
</blockquote>
<p>但最好的办法还是直接使用命令提示符来运行：</p>
<blockquote>
<p>php server.php</p>
</blockquote>
<p>但截至目前，上面的服务器端有<strong>三个问题</strong>：</p>
<ol>
<li>它不能接受多个连接。</li>
</ol>
<ol>
<li>它只完成唯一的一个命令。</li>
</ol>
<ol>
<li>你不能通过Web浏览器连接这个服务器。</li>
</ol>
<p>在上一个代码的基础上再改进，使用下面的代码来做新服务器端：</p>
<pre><code>:::PHP
&lt;?php
// Set up our socket 
$commonProtocol = getprotobyname(&quot;tcp&quot;);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, &#39;localhost&#39;, 1337);
socket_listen($socket);
// Initialize the buffer 
$buffer = &quot;NO DATA&quot;;
while(true)
{
    // Accept any connections coming in on this socket
    $connection = socket_accept($socket);
    printf(&quot;Socket connected\r\n&quot;);
    // Check to see if there is anything in the buffer
    if($buffer != &quot;&quot;)
    {
        printf(&quot;Something is in the buffer...sending data...\r\n&quot;);
        socket_write($connection, $buffer . &quot;\r\n&quot;);
        printf(&quot;Wrote to socket\r\n&quot;);
    }
    else
    {
        printf(&quot;No Data in the buffer\r\n&quot;);
    }
    // Get the input
    while($data = socket_read($connection, 1024, PHP_NORMAL_READ))
    {
        $buffer = $data;
        socket_write($connection, &quot;Information Received\r\n&quot;);
        printf(&quot;Buffer: &quot; . $buffer . &quot;\r\n&quot;);
    }
    socket_close($connection);
    printf(&quot;Closed the socket\r\n\r\n&quot;);
}
?&gt;
</code></pre><p>这段程序初始化一个socket并且打开一个缓冲区收发数据。然后服务器开始等待连接，此时一旦产生一个连接，服务器将打印“Socket connected”。然后服务器检查缓冲区，如果缓冲区里有数据，服务器就把这些数据发送到连接的计算机客户端。然后服务器等待接收信息，并把接收到的信息保存，然后让连接的客户端知道信息接收成功后，服务器将关闭连接。连接关闭后，服务器将开始下一次处理连接的循环。</p>
<h3 id="-">编写客户端</h3>
<p>解决上面提到的第二个问题还是比较容易的。我们需要一个连接到服务器的页面来处理数据并发送到服务器。</p>
<p>我们来看下面的代码：</p>
<pre><code>:::PHP
&lt;?php
// Create the socket and connect 
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
$connection = socket_connect($socket,’localhost’, 1337);
while($buffer = socket_read($socket, 1024, PHP_NORMAL_READ))
{
    if($buffer == “NO DATA”)
    {
        echo(“&lt;p&gt;NO DATA&lt;/p&gt;”);
        break;
    }
    else
    {
        // Do something with the data in the buffer 
        echo(“&lt;p&gt;Buffer Data: “ . $buffer . “&lt;/p&gt;”);
    }
}
echo(“&lt;p&gt;Writing to Socket&lt;/p&gt;”);
// Write some test data to our socket
if(!socket_write($socket, “SOME DATA\r\n”))
{
    echo(“&lt;p&gt;Write failed&lt;/p&gt;”);
}
// Read any response from the socket
while($buffer = socket_read($socket, 1024, PHP_NORMAL_READ))
{
    echo(“&lt;p&gt;Data sent was: SOME DATA&lt;br&gt; Response was:” . $buffer . “&lt;/p&gt;”);
}
echo(“&lt;p&gt;Done Reading from Socket&lt;/p&gt;”);
?&gt;
</code></pre><p>这个例子的客户端连接到服务器后，客户端读取数据。如果这是客户端第一次连接服务器，服务器将发送“NO DATA”给客户端。如果客户端收到“NO DATA”说明其连接成功，客户端发送它的数据到服务器并等待服务器响应。一旦客户端接收到服务器的响应，客户端将把响应内容输出到屏幕上。</p>
<h3 id="-">总结</h3>
<p>如果还想深入了解PHP Socket，建议阅读更多的第三方资料或到PHP官方查询官方文档。今天就介绍到这里，如果有错误欢迎指正。</p>
<p>参考资料：《PHP Game Programming》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hackecho.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2013/10/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a>
      </li>
    
      <li>
        <a href="/2013/04/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a>
      </li>
    
      <li>
        <a href="/2013/04/basics-of-mpi/">MPI 并行程序设计基础</a>
      </li>
    
      <li>
        <a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a>
      </li>
    
      <li>
        <a href="/2013/03/basic-of-gcc/">GCC 基础</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
<li><a href="http://vicdory.com/" title="Kailun Shi">Kailun Shi</a></li>
</ul>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Android,AsyncTask/">Android,AsyncTask</a><small>1</small></li>
  
    <li><a href="/tags/Android,SharedPreferences/">Android,SharedPreferences</a><small>1</small></li>
  
    <li><a href="/tags/BidData/">BidData</a><small>1</small></li>
  
    <li><a href="/tags/Decorator,Python/">Decorator,Python</a><small>1</small></li>
  
    <li><a href="/tags/GBK,Mac,UTF8/">GBK,Mac,UTF8</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Google+/">Google+</a><small>1</small></li>
  
    <li><a href="/tags/JSON,XML,PHP/">JSON,XML,PHP</a><small>1</small></li>
  
    <li><a href="/tags/Life/">Life</a><small>1</small></li>
  
    <li><a href="/tags/Linux,HFS/">Linux,HFS</a><small>1</small></li>
  
    <li><a href="/tags/MPI/">MPI</a><small>1</small></li>
  
    <li><a href="/tags/MVC, PHP/">MVC, PHP</a><small>1</small></li>
  
    <li><a href="/tags/PHP,Socket/">PHP,Socket</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>1</small></li>
  
    <li><a href="/tags/ThinkPHP/">ThinkPHP</a><small>1</small></li>
  
    <li><a href="/tags/WebSocket,HTML5/">WebSocket,HTML5</a><small>1</small></li>
  
    <li><a href="/tags/Wordpress/">Wordpress</a><small>2</small></li>
  
    <li><a href="/tags/boost,thread/">boost,thread</a><small>1</small></li>
  
    <li><a href="/tags/cuda,parallel,reduction/">cuda,parallel,reduction</a><small>1</small></li>
  
    <li><a href="/tags/fly-of-promgrammer/">fly-of-promgrammer</a><small>1</small></li>
  
    <li><a href="/tags/gcc/">gcc</a><small>1</small></li>
  
    <li><a href="/tags/ipc,semaphores/">ipc,semaphores</a><small>1</small></li>
  
    <li><a href="/tags/life/">life</a><small>1</small></li>
  
    <li><a href="/tags/makefile/">makefile</a><small>1</small></li>
  
    <li><a href="/tags/movie/">movie</a><small>1</small></li>
  
    <li><a href="/tags/open source/">open source</a><small>1</small></li>
  
    <li><a href="/tags/pthread/">pthread</a><small>1</small></li>
  
    <li><a href="/tags/web/">web</a><small>1</small></li>
  
    <li><a href="/tags/websocket/">websocket</a><small>1</small></li>
  
    <li><a href="/tags/极客/">极客</a><small>1</small></li>
  
    <li><a href="/tags/程序员/">程序员</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Zhaoyu Li
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'zlmoment';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>