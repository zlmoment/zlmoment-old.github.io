<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2013/2 | Hackecho</title>
  <meta name="author" content="Zhaoyu Li">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hackecho"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hackecho" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hackecho</a></h1>
  <h2><a href="/">Blog by Zhaoyu Li</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2013/2</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-12T03:48:00.000Z"><a href="/2013/02/ipc-semaphores/">Feb 11 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/ipc-semaphores/">IPC Semaphores</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="initializing-a-semaphore-set">Initializing a Semaphore Set</h3>
<p>The function <code>semget()</code> initializes or gains access to a semaphore.</p>
<pre><code>:::C
int semget(key_t key, int nsems, int semflg);
</code></pre><ul>
<li><p>The <code>key</code> argument is a access value associated with the semaphore ID.</p>
</li>
<li><p>The <code>nsems</code> argument specifies the number of elements in a semaphore array. The call fails when nsems is greater than the number of elements in an existing array; when the correct count is not known, supplying 0 for this argument ensures that it will succeed.</p>
</li>
<li><p>The <code>semflg</code> argument specifies the initial access permissions and creation control flags.</p>
</li>
</ul>
<p>When the call succeeds, it returns the semaphore ID (semid).</p>
<pre><code>:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
key_t key; /* key to pass to semget() */ 
int semflg; /* semflg to pass tosemget() */ 
int nsems; /* nsems to pass to semget() */ 
int semid; /* return value from semget() */ 

... 

key = 123456; 
nsems = 1;
semflg = IPC_CREAT | 0666; // Flag to create with rw permissions
// Create the semaphore
// The return value is the semaphore set identifier
if ((semid = semget(key, nsems, semflg)) == -1) {
    perror(&quot;semget: semget failed&quot;); 
     exit(1); 
} 
else 
   ...
</code></pre><h3 id="controlling-semaphores">Controlling Semaphores</h3>
<p><code>semctl()</code> changes permissions and other characteristics of a semaphore set. It is prototyped as follows:</p>
<pre><code>:::C
int semctl(int semid, int semnum, int cmd, union semun arg);
</code></pre><p>It must be called with a valid semaphore ID, semid. The <code>semnum</code> value selects a semaphore within an array by its index. The <code>cmd</code> argument is one of the following control flags:</p>
<p>GETVAL
-- Return the value of a single semaphore.</p>
<p>SETVAL
-- Set the value of a single semaphore. In this case, arg is taken as arg.val, an int.</p>
<p>GETPID
-- Return the PID of the process that performed the last operation on the semaphore or array.</p>
<p>GETNCNT
-- Return the number of processes waiting for the value of a semaphore to increase.</p>
<p>GETZCNT
-- Return the number of processes waiting for the value of a particular semaphore to reach zero.</p>
<p>GETALL
-- Return the values for all semaphores in a set. In this case, arg is taken as arg.array, a pointer to an array of unsigned shorts (see below).</p>
<p>SETALL
-- Set values for all semaphores in a set. In this case, arg is taken as arg.array, a pointer to an array of unsigned shorts.</p>
<p>IPC_STAT
-- Return the status information from the control structure for the semaphore set and place it in the data structure pointed to by arg.buf, a pointer to a buffer of type semid_ds.</p>
<p>IPC_SET
-- Set the effective user and group identification and permissions. In this case, arg is taken as arg.buf.</p>
<p>IPC_RMID
-- Remove the specified semaphore set.</p>
<p>The fourth argument <code>union semun</code> arg is optional, depending upon the operation requested. If required it is of type union semun, which must be explicitly declared by the application program as:</p>
<pre><code>:::C
union semun {
   int val;
   struct semid_ds *buf;
   ushort *array;
} arg;

:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt; 

// Initialize the semaphore
union semun {
   int val;
   struct semid_ds *buf;
   ushort *array;
} arg;

int semnum = ....;
int cmd = GETALL;   /* get value */

... 
if (semctl(semid, semnum, cmd, arg) &lt; 0) { 
    perror(&quot;semctl: semctl failed&quot;); 
    exit(1); 
}
else
    ...
</code></pre><h3 id="semaphore-operations">Semaphore Operations</h3>
<p><code>semop()</code> performs operations on a semaphore set.</p>
<pre><code>:::C
int semop(int semid, struct sembuf *sops, size_t nsops);
</code></pre><p>The <code>sops</code> argument is a pointer to an array of structures, each containing the following information about a semaphore operation:</p>
<pre><code>:::C
The semaphore number
The operation to be performed
Control flags, if any.
</code></pre><p>The <code>sembuf</code> structure specifies a semaphore operation, as defined in <code>sys/sem.h</code>.</p>
<pre><code>:::C
struct sembuf {
    ushort_t    sem_num;        /* semaphore number */
    short       sem_op;         /* semaphore operation */
    short       sem_flg;        /* operation flags */
};
</code></pre><p>The operation to be performed is determined as follows:</p>
<pre><code>:::C
A positive integer increments the semaphore value by that amount.
A negative integer decrements the semaphore value by that amount. An attempt to set a semaphore to a value less than zero fails or blocks, depending on whether IPC_NOWAIT is in effect.
A value of zero means to wait for the semaphore value to reach zero.


:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
int i; 
int nsops; /* number of operations to do */ 
int semid; /* semid of semaphore set */ 
struct sembuf *sops; /* ptr to operations to perform */ 

... 
// semop performs the operations on the semaphore:
if ((semid = semop(semid, sops, nsops)) == -1) 
{ 
    perror(&quot;semop: semop failed&quot;); 
    exit(1);
} 
else 
    (void) fprintf(stderr, &quot;semop: returned %d\n&quot;, i); 
    ...
</code></pre><h3 id="-">补充</h3>
<p>以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。</p>
<p>在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。</p>
<p>抽象的来讲，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程/进程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-05T23:04:00.000Z"><a href="/2013/02/make-your-program/">Feb 5 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/make-your-program/">Make Your Program</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这学期选了两门挺有意思的课，一门叫Programming High Performance Computing，还有一门Parallel and Distributed Processing。两周刚刚上下来，感觉传递的知识量有我之前悠哉悠哉一学期学到的都多。不知道是美国本科生的基础好还是美国大学的教育好，同班的美国同学接受这些知识看起来都毫无压力。不过语言确实是一个因素，比如HPC的老师两节课讲了几十个英文缩写，还都与电路有关，感觉回到了当年狂补计算机组成原理的时候。这些英文缩写估计对于美国学生接受起来要更好一点吧。我只有更努力了。</p>
<p>重新好好学习一下以前的知识，认真记住。PDP的教授第一节课说了一句话让我印象非常深刻，他说：“They value you not because what you can search but what you can do.”其实非常羡慕老教授课堂上信手拈来的各种复杂代码和命令参数，只靠Google是不行的。</p>
<p>本篇博客就来复习一下Makefile吧，这两门课每次交作业都要求必须包含Makefile，就像HPC的Slides中说的：“Real programmers use Makefiles!”</p>
<h3 id="outline">Outline</h3>
<ul>
<li><p>What&#39;s Makefile</p>
</li>
<li><p>Generating Multiple Targets</p>
</li>
<li><p>Macros</p>
</li>
</ul>
<h3 id="what-s-makefile">What&#39;s Makefile</h3>
<p>Under the UNIX shell, make is a command generator. The makefile is a description file which creates a sequence of commands for execution by the UNIX shell.</p>
<p>Generally, a program is built from one or more files and each of these files may have other files as prerequisites in turn. In a makefile, the prerequisites should be carefully stated. There are two important types of lines in a description file. A dependency line or rule line contains a colon, and a command line always starts <strong>with a tab</strong>.</p>
<p>To the left of the colon on the dependency line is a target; to the right of the colon are the target&#39;s prerequisites. If myprog has prerequisites a.c and b.c, we have</p>
<pre><code> myprog :  a.c  b.c
</code></pre><p>The command lines just tells make how to make the target. For example,</p>
<pre><code> myprog : a.c b.c
      gcc -o myprog a.c b.c
</code></pre><p>Then, type <code>make</code>, the UNIX prompt will excute the command as you typed.</p>
<h3 id="generating-multiple-targets">Generating Multiple Targets</h3>
<p>If we want to generate more than one programs, for example, let program prog01 depend on a.c and b.c, prog02 depend on m.c and n.c, and prog03 depend on u.c, v.c and w.c. </p>
<pre><code> all : prog01 prog02 prog03

 prog01 : a.c b.c
      gcc -o prog01 a.c b.c

 prog02 : m.c n.c
      gcc -o prog02 m.c n.c

 prog03 : u.c v.c w.c
      gcc -o prog03 u.c v.c w.c
</code></pre><p>Thus, if one of these three programs is not up-to-date, <code>all</code> will be generated which in turn causes all programs compiled. If the dependency line defining <code>all</code> is the first line of your Makefile, just type <code>make</code> will be the same as typing <code>make all</code>.</p>
<h3 id="macros">Macros</h3>
<p>A macro definition is a line containing an equal sign (=). When make encounters a name that appears to the left of the equal sign, that name is replaced by the contents to the right of the equal sign. It is not necessary to delimit the text string with double quote (&quot;) or single quote (&#39;). If they are used, they become part of the text string.</p>
<p>If we have the macro definition as follows,</p>
<pre><code> NAME = Zhaoyu Li
</code></pre><p>Then subsequent references to <code>${NAME}</code> or <code>$(NAME)</code> are interpreted as <code>Zhaoyu Li</code>.</p>
<h3 id="examples">Examples</h3>
<p>Here are two examples,</p>
<pre><code> SUBDIRS = src analyze

 all: subdirs test analysis
      @echo &quot;After Build, run &#39;make analysis&#39; to run analysis&quot;

 test: 
      @echo &quot;About to self-test&quot;; ./src/hw1

 analysis: 
      @cd analyze &amp;&amp; make analysis

 subdirs:
      @for dir in $(SUBDIRS); do \
           $(MAKE) -C $$dir; \
      done

 clean:
      @for dir in $(SUBDIRS); do \
           $(MAKE) -C $$dir clean; \
      done
</code></pre><p>Let&#39;s see another example. Suppose you are provided with two files, MyThreads.h and MyThreads.o. The former is a header file that has to be included into your source files and the latter is a library of functions for you to use. In other words, your source files in which multithreaded capability is used depend on MyThreads.h and your executable depends on MyThreads.o.</p>
<p>Suppose your assignment has the following files, prog01.c (the main function), and abc.c, def.c and xyz.c. All of these files contain access to multithread functions defined in MyThreads.h. You also designed some utility functions collected in files ut1.c and ut2.c. None of these two have access to the multithread capability. However, in your judgment, you believe any change made to ut1.c and ut2.c requires recompilation of abc.c and xyz.c. Therefore, on the source level, prog01.c, abc.c, def.c and xyz.c depend on MyThreads.h, and abc.c and xyz.c also depend on ut1.c and ut2.c. Suppose the final executable is to be called prog01.</p>
<pre><code> CC = gcc -ansi

 prog01 : prog01.o abc.o def.o xyz.o ut1.o ut2.o MyThreads.o
      ${CC} -o prog01 prog01.o abc.o def.o xyz.o ut1.o ut2.o MyThreads.o -lthread

 prog01.o : prog01.c MyThreads.h
      ${CC} -c prog01.c

 abc.o : abc.c c ut2.c MyThreads.h
      ${CC} -c abc.c
 def.o : def.c MyThreads.h
      ${CC} -c def.c
 xyz.o : xyz.c ut1.c ut2.c MyThreads.h
      ${CC} -c xyz.c

 ut1.o : ut1.c
      ${CC} -c ut1.c
 ut2.o : ut2.c
      ${CC} -c ut2.c
</code></pre><p>Above is the basic concepts of Makefile. If you want to be more expert, try the offcial documents.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-03T00:35:00.000Z"><a href="/2013/02/posix-threads-programming/">Feb 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/posix-threads-programming/">POSIX Threads Programming</a></h1>
  

    </header>
    <div class="entry">
      
        <p>I am writing this article for a memo of CS8860, Parallel and distributed system.</p>
<h3 id="overview">Overview</h3>
<p>Technically, a thread is defined as an independent stream of instructions that can be scheduled to run as such by the operating system.</p>
<p>In the UNIX environment a thread:</p>
<ul>
<li><p>Exists within a process and uses the process resources</p>
</li>
<li><p>Has its own independent flow of control as long as its parent process exists and the OS supports it</p>
</li>
<li><p>Duplicates only the essential resources it needs to be independently schedulable</p>
</li>
<li><p>May share the process resources with other threads that act equally independently (and dependently)</p>
</li>
<li><p>Dies if the parent process dies - or something similar</p>
</li>
<li><p>Is &quot;lightweight&quot; because most of the overhead has already been accomplished through the creation of its process.</p>
</li>
</ul>
<p>All threads within a process share the same address space.</p>
<h3 id="several-common-models">Several common models</h3>
<p>Several common models for threaded programs exist:</p>
<ul>
<li><p><strong>Manager/worker:</strong> a single thread, the manager assigns work to other threads, the workers. Typically, the manager handles all input and parcels out work to the other tasks. At least two forms of the manager/worker model are common: static worker pool and dynamic worker pool.</p>
</li>
<li><p><strong>Pipeline:</strong> a task is broken into a series of suboperations, each of which is handled in series, but concurrently, by a different thread. An automobile assembly line best describes this model.</p>
</li>
<li><p><strong>Peer:</strong> similar to the manager/worker model, but after the main thread creates other threads, it participates in the work.</p>
</li>
</ul>
<h3 id="shared-memory-model-">Shared Memory Model:</h3>
<ul>
<li><p>All threads have access to the same global, shared memory</p>
</li>
<li><p>Threads also have their own private data</p>
</li>
<li><p>Programmers are responsible for synchronizing access (protecting) globally shared data.</p>
</li>
</ul>
<h3 id="the-pthreads-api">The Pthreads API</h3>
<p>The Pthreads API contains around 100 subroutines. This article will focus on a subset of these.</p>
<h3 id="compiling-threaded-programs">Compiling Threaded Programs</h3>
<pre><code>INTEL Linux:          icc -pthread
PGI Linux:            pgcc -lpthread
GNU Linux:            gcc -pthread
</code></pre><h3 id="threading-management">Threading Management</h3>
<p><strong> Creating and Terminating Threads </strong></p>
<p>Initially, your <code>main()</code> program comprises a single, default thread. All other threads must be explicitly created by the programmer.</p>
<p><code>pthread_create</code> creates a new thread and makes it executable. This routine can be called any number of times from anywhere within your code.</p>
<p><code>pthread_create</code> arguments:</p>
<ul>
<li><p><code>thread:</code> An opaque, unique identifier for the new thread returned by the subroutine.</p>
</li>
<li><p><code>attr:</code> An opaque attribute object that may be used to set thread attributes. You can specify a thread attributes object, or NULL for the default values.</p>
</li>
<li><p><code>start_routine:</code> the C routine that the thread will execute once it is created.</p>
</li>
<li><p><code>arg:</code> A single argument that may be passed to start_routine. It must be passed by reference as a pointer cast of type void. NULL may be used if no argument is to be passed.</p>
</li>
</ul>
<p>Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads.</p>
<p>There are several ways in which a thread may be terminated:</p>
<ul>
<li><p>The thread returns normally from its starting routine. It&#39;s work is done.</p>
</li>
<li><p>The thread makes a call to the <code>pthread_exit</code> subroutine - whether its work is done or not.</p>
</li>
<li><p>The thread is canceled by another thread via the <code>pthread_cancel</code> routine.</p>
</li>
<li><p>The entire process is terminated due to making a call to either the <code>exec()</code> or <code>exit()</code></p>
</li>
<li><p>If <code>main()</code> finishes first, without calling <code>pthread_exit</code> explicitly itself</p>
</li>
</ul>
<p>Pay attention, the pthread_exit() routine does not close files; any files opened inside the thread will remain open after the thread is terminated.</p>
<p>Example:</p>
<pre><code>#include &lt;pthread.h&gt; 
#include &lt;stdio.h&gt; 
#define NUM_THREADS  5 

void *PrintHello(void *threadid) 
{ 
   int tid; 
   tid = (int)threadid; 
   printf(&quot;Hello World! It&#39;s me, thread #%d!\n&quot;, tid); 
   pthread_exit(NULL); 
} 

int main (int argc, char *argv[]) 
{ 
   pthread_t threads[NUM_THREADS]; 
   int rc, t; 
   for(t=0; t&lt;NUM_THREADS; t++){ 
      printf(&quot;In main: creating thread %d\n&quot;, t); 
      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); 
      if (rc){ 
         printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); 
         exit(-1); 
      } 
   } 
   pthread_exit(NULL); 
}
</code></pre><p><strong> Passing Arguments to Threads </strong></p>
<p>All arguments must be passed by reference and cast to (void *).</p>
<p><strong> Joining and Detaching Threads </strong></p>
<pre><code>:::C
int pthread_join(pthread_t target_thread, void **status);
</code></pre><p>&quot;Joining&quot; is one way to accomplish synchronization between threads. This means that some other thread is required to call pthread_join to collect a terminated thread, in a fashion similar to the requirement for a parent process to collect status for terminated child processes.For example:</p>
<p><a href="/images/2013/02/forkjoin.gif"><img src="/images/2013/02/forkjoin.gif" alt=""></a></p>
<p>The <code>pthread_join()</code> subroutine blocks the calling thread until the specified threadid thread terminates.</p>
<p>To explicitly create a thread as joinable or detached, the attr argument in the <code>pthread_create()</code> routine is used. The typical 4 step process is:</p>
<ul>
<li><p>Declare a pthread attribute variable of the <code>pthread_attr_t</code> data type</p>
</li>
<li><p>Initialize the attribute variable with <code>pthread_attr_init()</code></p>
</li>
<li><p>Set the attribute detached status with <code>pthread_attr_setdetachstate()</code></p>
</li>
<li><p>When done, free library resources used by the attribute with p<code>thread_attr_destroy()</code></p>
</li>
</ul>
<p>Example:</p>
<pre><code>:::C
/*****************************************************************************
 * FILE: join.c
 * DESCRIPTION:
 *   This example demonstrates how to &quot;wait&quot; for thread completions by using
 *   the Pthread join routine.  Threads are explicitly created in a joinable
 *   state for portability reasons. Use of the pthread_exit status argument is
 *   also shown. Compare to detached.c
 * AUTHOR: 8/98 Blaise Barney
 * LAST REVISED:  01/30/09
 ******************************************************************************/
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define NUM_THREADS    4

void *BusyWork(void *t)
{
    int i;
    long tid;
    double result=0.0;
    tid = (long)t;
    printf(&quot;Thread %ld starting...\n&quot;,tid);
    for (i=0; i&lt;1000000; i++)
    {
        result = result + sin(i) * tan(i);
    }
    printf(&quot;Thread %ld done. Result = %e\n&quot;,tid, result);
    pthread_exit((void*) t);
}

int main (int argc, char *argv[])
{
    pthread_t thread[NUM_THREADS];
    pthread_attr_t attr;
    int rc;
    long t;
    void *status;

    /* Initialize and set thread detached attribute */
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

    for(t=0; t&lt;NUM_THREADS; t++) {
        printf(&quot;Main: creating thread %ld\n&quot;, t);
        rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (void *)t);
        if (rc) {
            printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc);
            exit(-1);
        }
    }

    /* Free attribute and wait for the other threads */
    pthread_attr_destroy(&amp;attr);
    for(t=0; t&lt;NUM_THREADS; t++) {
        rc = pthread_join(thread[t], &amp;status);
        if (rc) {
            printf(&quot;ERROR; return code from pthread_join() is %d\n&quot;, rc);
            exit(-1);
        }
        printf(&quot;Main: completed join with thread %ld having a status of %ld\n&quot;,t,(long)status);
    }

    printf(&quot;Main: program completed. Exiting.\n&quot;);
    pthread_exit(NULL);
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hackecho.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/04/notes-about-maven/">Notes about Maven</a>
      </li>
    
      <li>
        <a href="/2014/04/hadoop-cluster-setup-instruction-with-fedora-20/">Hadoop Cluster Setup Instruction with Fedora 20</a>
      </li>
    
      <li>
        <a href="/2013/10/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a>
      </li>
    
      <li>
        <a href="/2013/04/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a>
      </li>
    
      <li>
        <a href="/2013/04/basics-of-mpi/">MPI 并行程序设计基础</a>
      </li>
    
      <li>
        <a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a>
      </li>
    
      <li>
        <a href="/2013/03/basic-of-gcc/">GCC 基础</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
	<li><a href="http://vicdory.com/" target="_blank" title="Kailun Shi">Kailun Shi</a></li>
	<li><a href="http://guo-min-zhi.github.io/" target="_blank" title="远方">远方</a></li>
	<li><a href="http://mingplusplus.com/blog/" target="_blank" title="Ming++">Ming++</a></li>
	<li><a href="http://ruiwu.me/" target="_blank" title="RuiWu">RuiWu</a></li>
</ul>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Android,AsyncTask/">Android,AsyncTask</a><small>1</small></li>
  
    <li><a href="/tags/Android,SharedPreferences/">Android,SharedPreferences</a><small>1</small></li>
  
    <li><a href="/tags/BidData/">BidData</a><small>1</small></li>
  
    <li><a href="/tags/Decorator,Python/">Decorator,Python</a><small>1</small></li>
  
    <li><a href="/tags/GBK,Mac,UTF8/">GBK,Mac,UTF8</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Google+/">Google+</a><small>1</small></li>
  
    <li><a href="/tags/Hadoop/">Hadoop</a><small>1</small></li>
  
    <li><a href="/tags/JSON,XML,PHP/">JSON,XML,PHP</a><small>1</small></li>
  
    <li><a href="/tags/Life/">Life</a><small>1</small></li>
  
    <li><a href="/tags/Linux,HFS/">Linux,HFS</a><small>1</small></li>
  
    <li><a href="/tags/MPI/">MPI</a><small>1</small></li>
  
    <li><a href="/tags/MVC, PHP/">MVC, PHP</a><small>1</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>1</small></li>
  
    <li><a href="/tags/PHP,Socket/">PHP,Socket</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>1</small></li>
  
    <li><a href="/tags/ThinkPHP/">ThinkPHP</a><small>1</small></li>
  
    <li><a href="/tags/WebSocket,HTML5/">WebSocket,HTML5</a><small>1</small></li>
  
    <li><a href="/tags/Wordpress/">Wordpress</a><small>2</small></li>
  
    <li><a href="/tags/boost,thread/">boost,thread</a><small>1</small></li>
  
    <li><a href="/tags/cuda,parallel,reduction/">cuda,parallel,reduction</a><small>1</small></li>
  
    <li><a href="/tags/fly-of-promgrammer/">fly-of-promgrammer</a><small>1</small></li>
  
    <li><a href="/tags/gcc/">gcc</a><small>1</small></li>
  
    <li><a href="/tags/ipc,semaphores/">ipc,semaphores</a><small>1</small></li>
  
    <li><a href="/tags/life/">life</a><small>1</small></li>
  
    <li><a href="/tags/makefile/">makefile</a><small>1</small></li>
  
    <li><a href="/tags/movie/">movie</a><small>1</small></li>
  
    <li><a href="/tags/open source/">open source</a><small>1</small></li>
  
    <li><a href="/tags/pthread/">pthread</a><small>1</small></li>
  
    <li><a href="/tags/web/">web</a><small>1</small></li>
  
    <li><a href="/tags/websocket/">websocket</a><small>1</small></li>
  
    <li><a href="/tags/极客/">极客</a><small>1</small></li>
  
    <li><a href="/tags/程序员/">程序员</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Zhaoyu Li
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'zlmoment';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- InstantClick makes following links in your website instant. http://instantclick.io -->
<script src="/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
</body>
</html>