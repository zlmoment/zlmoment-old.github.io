<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2013/3 | Hackecho</title>
  <meta name="author" content="Zhaoyu Li">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hackecho"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hackecho" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hackecho</a></h1>
  <h2><a href="/">Blog by Zhaoyu Li</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2013/3</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-21T21:49:00.000Z"><a href="/2013/03/a-letter-to-myself/">Mar 21 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a></h1>
  

    </header>
    <div class="entry">
      
        <p>2009年9月，进入大学的第一天，开始了我正式的软件工程的学习。为什么是正式的呢，因为之前虽然也写过代码，但完全是出于兴趣，想到什么就学什么，毫无章法。后来来到了北交大，进入了据说还不错的软件学院，有了一群志同道合的朋友，一位位用心良苦的老师，踏上了一个“程序员“的冒险旅程。现在，我在美国密苏里大学读计算机硕士，回首自己走过来的这四年，错过了很多，也明白了很多，收获了很多，对软件和计算机渐渐有了自己的认识，更重要的是，发现了自己越来越多的缺陷与不足。有些当年认为用处不大而忽略掉的东西，却成了现在最最重要的东西。有时会后悔地埋怨自己当时不努力，欠下了太多的债，只能后来慢慢偿还。</p>
<p>如果能够给我一次机会与四年前的我通话，我有太多的东西想对他说。然而，也许几年后再次回首，我会有另一番不同的思绪，但此时此景，我能想到这些，至少现在是对的，我不想后悔，把这些写下来，算是一种慰藉吧。</p>
<h3 id="-">多出去走走，开阔眼界</h3>
<p>“世界就像一本书，不旅行的人，只读过这本书里的一页。”</p>
<p>世界之大，无奇不有，不管你是否要做一个技术男，你都应该出去走走，去看更多的风景，去见更多的人，去体会更多的风情。不要做井底之蛙，这个世界到处都是精彩的事物，而有些东西如果不去亲自体会是永远无法得到的。没有人规定程序员就必须整天埋在代码中，上天赋予了程序员自由的职业特性，就一定要利用好它。程序本身就是一种美，你要时刻保持一颗欣赏美、涉猎美的心灵，才能更好地去发现和创造。眼界开阔了，心灵才不会收拘束。真的，这个世界太美好，去发现感动到哭的美。</p>
<p>你要做一个旅行家里代码写得最好的人！</p>
<h3 id="-">不要沉迷社交网络，线下的生活更加丰富</h3>
<p>碎片化的信息正在侵袭着我们的生活，社交网络的发明让我们能够在网上互动和交流。但你要问自己，这些真的对你有用处吗？当你和周围的朋友们沉迷于人人网微博消耗时间时，是否意识时间正在疯狂地消逝，等关闭网页的瞬间，你是否感觉到孤独感重新来袭。</p>
<p>最近刚看了《黑镜》第二季，第一集中男主人公沉迷于社交网络，有一天车祸不幸去世后，有人制作了一个机器人，根据他生前在社交网络上的言行，让他继续虚拟地活下去。当然结局你应该猜到了，是的，这个人没有情感，有些东西是永远无法从社交网络上模拟的。</p>
<p>线下的生活更精彩，你要多参加有益的社团、活动，多交朋友，在真实生活中维持真实的感情。</p>
<h3 id="-c-">打好C语言基础，掌握并深入一门编程语言</h3>
<p>在后来的学习中，尤其是这几个月来在国外的学习，让我渐渐感受到一些教育上的差异。C语言作为你正式学习的第一门语言，你要做到的不是掌握语法这么简单。语言是指一种工具，帮助你理解程序设计的思想和奥秘。如果有可能的话，我希望你开始研读Linux设计思想和源码，理解其中各种设计模型和理念，因为这些才是根，当你真正了理解了这些，就会发现所有的语言都是互通的，都遵循了一个准则，即使有新的思想，你也会很快接受并融会贯通的。</p>
<p>说到语言是工具，你当然要选择一门语言并试图做到精通。建议你学习C++，因为它更接近软件的底层和实质。掌握并精通它，理解它的一切，并在现有的基础上创新。Java封装的太多，你可以用Java来很好地理解面向对象的设计原则，来快速地开发一些程序，但Java会限制你的提高。当然你可以做一个Java界的大牛，但你想想，除非你特别喜欢这门语言，否则不要被它框住。</p>
<h3 id="-">一定要学好的课程，一定要读的书，一定要掌握的技术</h3>
<p>这几门课程是你一定要认真学习的，因为有一天你会发现它们非常重要：“数学方面的课程”、“数据结构”、“算法设计”、“操作系统”、“数据库”和“系统级编程”等。</p>
<p>这几本书不管你有多忙，都希望你能好好研读：《算法导论》，《代码大全》，《编程珠玑》外加多本文学书籍。</p>
<p>这几个技术一定要用心学习，因为它们真的很有用：Linux（内核+概念+应用），数据库，汇编与编译，调试，算法设计等。</p>
<h3 id="-">广泛涉猎，但不要丧失重心</h3>
<p>技术行业里永远有新的技术，不要让你的大脑僵化，要勇于去尝试新的东西，了解各个细分的行业，了解各项技术，广泛涉猎。因为只有这样，你才能发现什么是你真正喜欢的，真正感兴趣的。当你找到了自己真正的兴趣所在，你的所有研究和工作都将是快乐的。</p>
<p>另外，树立一个榜样，如果你决定要做一个商人，可以选择比尔盖茨、乔布斯，如果你决定要做研究，可以选择Linus，高德纳等技术流。抱着一种学习的心态去看待，不要盲目崇拜。</p>
<h3 id="-">好好学习一门脚本语言</h3>
<p>学习一门脚本语言如Python或Ruby。建议学习Python，并好好掌握它，这样可以让你更快速地与计算机交互，帮你快速解决某些问题。Python也有很多各方面的、优秀的框架，在Server开发、科学计算等方面都有很大的潜力。另外，PHP可以让你快速地架设一个小型网站，而且开源的系统也非常多。所有的这些工具，都可以在你需要的时候帮助到你。</p>
<h3 id="-">保持一颗好奇心，一颗童心</h3>
<p>时刻关注业界信息，关注各个IT公司动态，关注科技新闻，关注创业，向过来人吸取经验。你看得越多，分析的越多，你对业界的信息、发展的感知就会越敏锐。不要盲目跟风网上的言论，学会自己分析。</p>
<p>保持一颗童心，你才能保持一颗创造性的心，不要僵化思维，不要定势思维。这些都是需要训练的，相信你经过这些历练，一定可以有所进步。</p>
<p>最后，珍惜时间，珍惜生命，做最好的自己。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-04T16:18:00.000Z"><a href="/2013/03/basic-of-gcc/">Mar 4 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/basic-of-gcc/">GCC 基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p>GCC，糊里糊涂地用了好长时间，每次也都是简简单单的 <code>gcc test.cpp</code> 这样简单的命令，偶尔会用一下 <code>-o</code>。说实话C和C++写的确实也不多，大一的时候还处于懵懂时期，跟着老师用VC6，后来面向对象编程之后，几乎工作都在IDE下完成，对这类命令行下的编译指令接触更是甚少。如今才体会到什么叫书到用时方恨少，不得不回过头来再打基础，认真学习。</p>
<p>鉴于这不是一篇Tutorial，只是我的一篇笔记，所以并不会涵盖所有内容。</p>
<h3 id="-">基础</h3>
<p>gcc 命令只能编译 C++ 源文件，而不能自动和 C++ 程序使用的库连接。因此，通常使用 g++ 命令来完成 C++ 程序的编译和连接，该程序会自动调用 gcc 实现编译。</p>
<p>一般来讲，编译过程分为四个阶段：预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。下面举几个例子，关于参数的详细解释在文后会有。</p>
<p><strong>预编译</strong></p>
<pre><code>:::Bash
gcc -E test.c -o test.i 或 gcc -E test.c
</code></pre><p>预编译之后的文件还是代码文件，比如将会将 <code>stdio.h</code> 文件中的内容插入到自己程序中。</p>
<p><strong>编译</strong></p>
<pre><code>:::Bash
gcc -S test.i -o test.s
</code></pre><p><strong>汇编</strong></p>
<pre><code>:::Bash
gcc -c test.s -o test.o
</code></pre><p><strong>连接</strong></p>
<pre><code>:::Bash
gcc test.o -o test
</code></pre><h3 id="-">库文件</h3>
<p>函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。Linux下的大多数函数都默认将头文件放到 <code>/usr/include/</code> 目录下，而库文件则放到 <code>/usr/lib/</code> 目录下；Windows所使用的库文件主要放在Visual Stido的目录下的 <code>include</code> 和 <code>lib</code> ，以及系统文件夹下。放在 <code>/lib</code> 和 <code>/usr/lib</code> 和 <code>/usr/local/lib</code> 里的库直接用 <code>-l</code> 参数就能链接了（关于 <code>-l</code> 参数见文后详解）。</p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>静态库链接搜索路径顺序：</p>
<ol>
<li>参数-L</li>
<li>gcc的环境变量LIBRARY_PATH</li>
<li>内定目录 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code> ，这是当初compile gcc时写在程序内的</li>
</ol>
<p>动态链接时、执行时搜索路径顺序:</p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code></li>
</ol>
<p>有关环境变量：</p>
<ul>
<li><code>LIBRARY_PATH</code> ：指定程序静态链接库文件搜索路径</li>
<li><code>LD_LIBRARY_PATH</code> ：指定程序动态链接库文件搜索路径</li>
</ul>
<h3 id="-">参数</h3>
<p>先看几个比较重要的，常用的。</p>
<p><span class="label label-info">-l 和 -L</span></p>
<p><code>-l</code> 用来指定连接的库，其后紧跟<strong>库名</strong>。库名是把真实文件名的头部 <code>lib</code> 和尾部 <code>.so</code> 去掉，如要链接 <code>libmysqlclient.so</code> 库，则应使用 <code>-lmysqlclient</code> 命令。其中，放在 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code> 中的库可以直接调用（见上一部分中的搜索路径说明）。然而，放在其它目录的库则需要使用 <code>-L</code> 调用，其使用方法是在 -L 后紧跟<strong>库目录</strong>。</p>
<p><span class="label label-info">-o FILE</span></p>
<p>生成指定的输出可执行文件。</p>
<p><span class="label label-info">-include 和 -I</span></p>
<p><code>-include</code> 用来包含头文件，但一般情况下包含头文件都在源码里用 #include 实现。-I参数是用来指定<strong>头文件目录</strong>，路径参数可以使用绝对路径，也可以使用相对路径。</p>
<p>头文件的搜索路径顺序：</p>
<ol>
<li>参数-I</li>
<li>gcc的环境变量 C_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJC_INCLUDE_PATH</li>
<li>内定目录<ul>
<li>/usr/include  </li>
<li>/usr/local/include</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/include</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../include/g++-3</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../i386-linux/include</li>
</ul>
</li>
</ol>
<p><span class="label label-info">-O</span></p>
<ul>
<li>-O0 不进行优化处理。 </li>
<li>-O 或 -O1 优化生成代码。 </li>
<li>-O2 进一步优化。 </li>
<li>-O3 比 -O2 更进一步优化，包括 inline 函数。 </li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><span class="label label-info">-w</span> ：不生成任何警告信息。 </li>
<li><span class="label label-info">-Wall</span> ：生成所有警告信息。</li>
<li><span class="label label-info">-DMACRO</span> ：以字符串“1”定义 MACRO 宏。 </li>
<li><span class="label label-info">-DMACRO=DEFN</span> ：以字符串“DEFN”定义 MACRO 宏。</li>
<li><span class="label label-info">-c</span> ：只编译并生成目标文件。 </li>
<li><span class="label label-info">-E</span> ：只运行 C 预编译器。 </li>
<li><span class="label label-info">-g</span> ：生成调试信息。GNU 调试器可利用该信息。 </li>
<li><span class="label label-info">-m486</span> ：针对 486 进行代码优化。 </li>
<li><span class="label label-info">-shared</span> ：生成共享目标文件。通常用在建立共享库时。 </li>
<li><span class="label label-info">-static</span> ：强制使用静态链接。 </li>
<li><span class="label label-info">-UMACRO</span> ：取消对 MACRO 宏的定义。</li>
<li><span class="label label-info">-ansi</span> ：只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色，例如 asm 或 typeof 关键词。 </li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-04T04:35:00.000Z"><a href="/2013/03/boost-thread/">Mar 3 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/boost-thread/">Boost Thread</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这是一篇方法总结和作业笔记，已备需要的时候查阅。本文将介绍C++ Boost库 <code>Boost.Thread</code> ，用于开发独立于平台的多线程应用程序。</p>
<h3 id="-">线程创建</h3>
<p>相关类为 <code>boost::thread</code> ，定义在 <code>boost/thread.hpp</code> 中，用于创建一个新线程。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        std::cout &lt;&lt; i &lt;&lt; std::endl; 
    } 
} 

int main() 
{ 
    boost::thread t(thread); 
    t.join(); 
} 
</code></pre><p><strong>Notes:</strong></p>
<p>一旦上面例子中的变量 <code>t</code> 被创建，该 <code>thread()</code> 函数就在其所在线程中被立即执行， <code>join()</code> 的方法跟POSIX pthread中意义一样。</p>
<h3 id="-">线程中断</h3>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    try 
    { 
        for (int i = 0; i &lt; 5; ++i) 
        { 
            wait(1); 
            std::cout &lt;&lt; i &lt;&lt; std::endl; 
        } 
    } 
    catch (boost::thread_interrupted&amp;) 
    { 

} 

int main() 
{ 
    boost::thread t(thread); 
    wait(3); 
    t.interrupt(); 
    t.join(); 
} 
</code></pre><p>在一个线程对象上调用 <code>interrupt()</code> 会中断相应的线程，就是说一个类型为 <code>boost::thread_interrupted</code> 的异常会在这个线程中抛出。 然后这只有在线程达到中断点时才会发生。如果给定的线程不包含任何中断点，简单调用 <code>interrupt()</code> 就不会起作用。每当遇到一个线程中断点，它就会检查 <code>interrupt()</code> 是否被调用过。只有被调用过了， <code>boost::thread_interrupted</code> 异常才会相应地抛出。</p>
<p>下列函数中包含线程的中断检查点：</p>
<ul>
<li>boost::thread::join()</li>
<li>boost::thread::timed_join()</li>
<li>boost::thread::try_join_for(),</li>
<li>boost::thread::try_join_until(),</li>
<li>boost::condition_variable::wait()</li>
<li>boost::condition_variable::timed_wait()</li>
<li>boost::condition_variable::wait_for()</li>
<li>boost::condition_variable::wait_until()</li>
<li>boost::condition_variable_any::wait()</li>
<li>boost::condition_variable_any::timed_wait()</li>
<li>boost::condition_variable_any::wait_for()</li>
<li>boost::condition_variable_any::wait_until()</li>
<li>boost::thread::sleep()</li>
<li>boost::this_thread::sleep_for()</li>
<li>boost::this_thread::sleep_until()</li>
<li>boost::this_thread::interruption_point()</li>
</ul>
<h3 id="-">同步</h3>
<p>设计到线程的地方就会出现竞争条件(race condition)，所以进行同步是必不可少的。</p>
<p>最简单的 <code>boost::mutex</code> 类。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

boost::mutex mutex; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        mutex.lock(); 
        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
        mutex.unlock(); 
    } 
} 

int main() 
{ 
    boost::thread t1(thread); 
    boost::thread t2(thread); 
    t1.join(); 
    t2.join(); 
} 
</code></pre><p>也可以使用 <code>boost::lock_guard</code> 类，来避免直接调用 <code>lock()</code> 和 <code>unlock()</code> 。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

boost::mutex mutex; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        boost::lock_guard&lt;boost::mutex&gt; lock(mutex); 
        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
    } 
} 

int main() 
{ 
    boost::thread t1(thread); 
    boost::thread t2(thread); 
    t1.join(); 
    t2.join(); 
} 
</code></pre><p><code>boost::lock_guard</code> 在其构造和析构函数分别自动调用 <code>lock()</code> 和 <code>unlock()</code> 。</p>
<h3 id="reference">Reference</h3>
<ul>
<li><p>Boost多线程 <a href="http://zh.highscore.de/cpp/boost/" target="_blank"><a href="http://zh.highscore.de/cpp/boost/">http://zh.highscore.de/cpp/boost/</a></a></p>
</li>
<li><p>Boost Thread Documentation <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html" target="_blank"><a href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></a></p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hackecho.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2013/10/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a>
      </li>
    
      <li>
        <a href="/2013/04/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a>
      </li>
    
      <li>
        <a href="/2013/04/basics-of-mpi/">MPI 并行程序设计基础</a>
      </li>
    
      <li>
        <a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a>
      </li>
    
      <li>
        <a href="/2013/03/basic-of-gcc/">GCC 基础</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
<li><a href="http://vicdory.com/" title="Kailun Shi">Kailun Shi</a></li>
</ul>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Android,AsyncTask/">Android,AsyncTask</a><small>1</small></li>
  
    <li><a href="/tags/Android,SharedPreferences/">Android,SharedPreferences</a><small>1</small></li>
  
    <li><a href="/tags/BidData/">BidData</a><small>1</small></li>
  
    <li><a href="/tags/Decorator,Python/">Decorator,Python</a><small>1</small></li>
  
    <li><a href="/tags/GBK,Mac,UTF8/">GBK,Mac,UTF8</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Google+/">Google+</a><small>1</small></li>
  
    <li><a href="/tags/JSON,XML,PHP/">JSON,XML,PHP</a><small>1</small></li>
  
    <li><a href="/tags/Life/">Life</a><small>1</small></li>
  
    <li><a href="/tags/Linux,HFS/">Linux,HFS</a><small>1</small></li>
  
    <li><a href="/tags/MPI/">MPI</a><small>1</small></li>
  
    <li><a href="/tags/MVC, PHP/">MVC, PHP</a><small>1</small></li>
  
    <li><a href="/tags/PHP,Socket/">PHP,Socket</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>1</small></li>
  
    <li><a href="/tags/ThinkPHP/">ThinkPHP</a><small>1</small></li>
  
    <li><a href="/tags/WebSocket,HTML5/">WebSocket,HTML5</a><small>1</small></li>
  
    <li><a href="/tags/Wordpress/">Wordpress</a><small>2</small></li>
  
    <li><a href="/tags/boost,thread/">boost,thread</a><small>1</small></li>
  
    <li><a href="/tags/cuda,parallel,reduction/">cuda,parallel,reduction</a><small>1</small></li>
  
    <li><a href="/tags/fly-of-promgrammer/">fly-of-promgrammer</a><small>1</small></li>
  
    <li><a href="/tags/gcc/">gcc</a><small>1</small></li>
  
    <li><a href="/tags/ipc,semaphores/">ipc,semaphores</a><small>1</small></li>
  
    <li><a href="/tags/life/">life</a><small>1</small></li>
  
    <li><a href="/tags/makefile/">makefile</a><small>1</small></li>
  
    <li><a href="/tags/movie/">movie</a><small>1</small></li>
  
    <li><a href="/tags/open source/">open source</a><small>1</small></li>
  
    <li><a href="/tags/pthread/">pthread</a><small>1</small></li>
  
    <li><a href="/tags/web/">web</a><small>1</small></li>
  
    <li><a href="/tags/websocket/">websocket</a><small>1</small></li>
  
    <li><a href="/tags/极客/">极客</a><small>1</small></li>
  
    <li><a href="/tags/程序员/">程序员</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Zhaoyu Li
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'hackecho';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>