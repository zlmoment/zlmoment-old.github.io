<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2012/4 | Hackecho</title>
  <meta name="author" content="Zhaoyu Li">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hackecho"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hackecho" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hackecho</a></h1>
  <h2><a href="/">Blog by Zhaoyu Li</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2012/4</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-04-30T00:03:08.000Z"><a href="/2012/04/29/new-hybi-10-protocol-of-websocket/">Apr 29 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/04/29/new-hybi-10-protocol-of-websocket/">WebSocket新版Hybi-10协议介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <p>不知道问什么，网上的几乎所有关于WebSocket的讲解都是旧版协议，开源的PHP-WebSocket也早不更新了。一开始还以为是服务器程序的原因，后来发现是协议变更了。而且好不容易将握手协议更换为新版后，发现传送的数据都是乱码（见<a href="http://weibo.com/1784705505/ygyi4A0Pj" target="_blank">这里</a>），原来数据报文的格式也进行了非常大的变更！</p>
<p>之前我们曾介绍过基于WebSocket协议的服务器实现，但那篇文章中提到的WebSocket协议标准还是草案7.5、7.6的标准，如今只有Safari支持此版本的协议，Chrome和Firefox最新版都已升级至Hybi-10（<a href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10" target="_blank">协议地址</a>）。因此，我们再来介绍一下WebSocket新版协议Hybi-10。这次协议变更非常大，主要集中在握手协议和数据传输的格式上。下面我们来详细介绍一下。</p>
<h3 id="-">握手协议</h3>
<p>我们先来看一下大致的区别：</p>
<ol>
<li>最老的websocket草案标准中是没有安全key，草案7.5、7.6中有两个安全key，而现在的草案10中只有一个安全key，即将7.5、7.6中http头中的&quot;Sec-WebSocket-Key1&quot;与&quot;Sec-WebSocket-Key2&quot;合并为了一个&quot;Sec-WebSocket-Key&quot;</li>
</ol>
<ol>
<li>把http头中Upgrade的值由&quot;WebSocket&quot;修改为了&quot;websocket&quot;；http头中的&quot;-Origin&quot;修改为了&quot;Sec-WebSocket-Origin&quot;;</li>
</ol>
<ol>
<li>增加了http头&quot;Sec-WebSocket-Accept&quot;，用来返回原来草案7.5、7.6服务器返回给客户端的握手验证，原来是以内容的形式返回，现在是放到了http头中；另外服务器返回客户端的验证方式也有变化。</li>
</ol>
<p>服务器生成验证的方式变化较大，我们来做一介绍。</p>
<p>旧版：</p>
<pre><code>GET / HTTP/1.1
Upgrade: WebSocket
Connection: Upgrade
Host: 127.0.0.1:1337
Origin: http://127.0.0.1:8000
Cookie: sessionid=xxxx; calView=day; dayCurrentDate=1314288000000
Sec-WebSocket-Key1: cV`p1* 42#7  ^9}_ 647  08{
Sec-WebSocket-Key2: O8 415 8x37R A8   4
;&quot;######
</code></pre><p>旧版生成Token的方法如下：</p>
<p>取出Sec-WebSocket-Key1中的所有数字字符形成一个数值，这里是1427964708，然后除以Key1中的空格数目，得到一个数值，保留该数值整数位，得到数值N1；对Sec-WebSocket-Key2采取同样的算法，得到第二个整数N2；把N1和N2按照Big-Endian字符序列连接起来，然后再与另外一个Key3连接，得到一个原始序列ser_key。Key3是指在握手请求最后，有一个8字节的奇怪的字符串“;”######”，这个就是Key3。然后对ser_key进行一次md5运算得出一个16字节长的digest，这就是老版本协议需要的token，然后将这个token附在握手消息的最后发送回Client，即可完成握手。</p>
<p>新版：</p>
<pre><code>GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: 127.0.0.1:1337
Sec-WebSocket-Origin: http://127.0.0.1:8000
Sec-WebSocket-Key: erWJbDVAlYnHvHNulgrW8Q==
Sec-WebSocket-Version: 8
Cookie: csrftoken=xxxxxx; sessionid=xxxxx
</code></pre><p>新版生成Token的方法如下：</p>
<p>首先服务器将key（长度24）截取出来，如4tAjitqO9So2Wu8lkrsq3w==，用它和自定义的一个字符串（长度36）258EAFA5-E914-47DA-95CA-C5AB0DC85B11连接起来，然后把这一字符串进行SHA-1算法加密，得到长度为20字节的二进制数据，再将这些数据经过Base64编码，最终得到服务端的密钥，也就是ser_key。服务器将ser_key附在返回值Sec-WebSocket-Accept后，至此握手成功。</p>
<h3 id="-">数据报文格式</h3>
<p>旧版协议比较简单，仅仅是在原始数据前加了个’\x00′，在最后面加了个’\xFF’，即假如Client发送一个字符串’test’，实际上WebSocket Server收到的数据是：’x00test\xFF’，所以只需要剥离掉首尾那两个字符就可以了。</p>
<p>新版的协议对这部分规定比较复杂，以下是其格式标准：（下图在Firefox可能会出现错乱，请换用Chrome）</p>
<pre><code>      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/63)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
</code></pre><p><strong>FIN：</strong>1位，用来表明这是一个消息的最后的消息片断，当然第一个消息片断也可能是最后的一个消息片断；</p>
<p><strong>RSV1, RSV2, RSV3:</strong> 分别都是1位，如果双方之间没有约定自定义协议，那么这几位的值都必须为0,否则必须断掉WebSocket连接；</p>
<p><strong>Opcode:</strong>4位操作码，定义有效负载数据，如果收到了一个未知的操作码，连接也必须断掉，以下是定义的操作码：</p>
<ul>
<li>%x0 表示连续消息片断</li>
</ul>
<ul>
<li>%x1 表示文本消息片断</li>
</ul>
<ul>
<li>%x2 表未二进制消息片断</li>
</ul>
<ul>
<li>%x3-7 为将来的非控制消息片断保留的操作码</li>
</ul>
<ul>
<li>%x8 表示连接关闭</li>
</ul>
<ul>
<li>%x9 表示心跳检查的ping</li>
</ul>
<ul>
<li>%xA 表示心跳检查的pong</li>
</ul>
<ul>
<li>%xB-F 为将来的控制消息片断的保留操作码</li>
</ul>
<p><strong>Mask:</strong>1位，定义传输的数据是否有加掩码,如果设置为1,掩码键必须放在masking-key区域，客户端发送给服务端的所有消息，此位的值都是1；</p>
<p><strong>Payload length: </strong>传输数据的长度，以字节的形式表示：7位、7+16位、或者7+64位。如果这个值以字节表示是0-125这个范围，那这个值就表示传输数据的长度；如果这个值是126，则随后的两个字节表示的是一个16进制无符号数，用来表示传输数据的长度；如果这个值是127,则随后的是8个字节表示的一个64位无符合数，这个数用来表示传输数据的长度。多字节长度的数量是以网络字节的顺序表示。负载数据的长度为扩展数据及应用数据之和，扩展数据的长度可能为0,因而此时负载数据的长度就为应用数据的长度。</p>
<p><strong>Masking-key:</strong>0或4个字节，客户端发送给服务端的数据，都是通过内嵌的一个32位值作为掩码的；掩码键只有在掩码位设置为1的时候存在。
<strong>Payload data: </strong> (x+y)位，负载数据为扩展数据及应用数据长度之和。
<strong>Extension data:</strong>x位，如果客户端与服务端之间没有特殊约定，那么扩展数据的长度始终为0，任何的扩展都必须指定扩展数据的长度，或者长度的计算方式，以及在握手时如何确定正确的握手方式。如果存在扩展数据，则扩展数据就会包括在负载数据的长度之内。
<strong>Application data:</strong>y位，任意的应用数据，放在扩展数据之后，应用数据的长度=负载数据的长度-扩展数据的长度。</p>
<p>以下是Python实现的解码和编码，兼容新旧版协议，仅供参考：</p>
<pre><code>:::Python
def send_data(self, raw_str):
    if self.sockets[self][&#39;new_version&#39;]:
        back_str = []
        back_str.append(&#39;\x81&#39;)
        data_length = len(raw_str)

        if data_length &lt;= 125:
            back_str.append(chr(data_length))
        else:
            back_str.append(chr(126))
            back_str.append(chr(data_length &gt;&gt; 8))
            back_str.append(chr(data_length &amp; 0xFF))

        back_str = &quot;&quot;.join(back_str) + raw_str
        self.transport.write(back_str)
    else:
        back_str = &#39;\x00%s\xFF&#39; % (raw_str)
        self.transport.write(back_str)

def parse_recv_data(self, msg):
    raw_str = &#39;&#39;

    if self.sockets[self][&#39;new_version&#39;]:
        code_length = ord(msg[1]) &amp; 127

        if code_length == 126:
            masks = msg[4:8]
            data = msg[8:]
        elif code_length == 127:
            masks = msg[10:14]
            data = msg[14:]
        else:
            masks = msg[2:6]
            data = msg[6:]

        i = 0
        for d in data:
            raw_str += chr(ord(d) ^ ord(masks[i%4]))
            i += 1
    else:
        raw_str = msg.split(&quot;\xFF&quot;)[0][1:]

    return raw_str
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-04-17T05:46:21.000Z"><a href="/2012/04/17/socket-programming-in-php/">Apr 17 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/04/17/socket-programming-in-php/">PHP中的Socket编程</a></h1>
  

    </header>
    <div class="entry">
      
        <p>关于PHP socket的资料网上着实不多，或者讲的都不是很全面。为了更好地用PHP来处理socket，天堂皓月博客特地来简单总结一下其用法，尽量会做到深入浅出：）</p>
<h3 id="-">文章结构：</h3>
<ul>
<li>Socket基础知识</li>
</ul>
<ul>
<li>编写服务器</li>
</ul>
<ul>
<li>编写客户端</li>
</ul>
<ul>
<li>总结</li>
</ul>
<p>通过这三部分你将会体验到Socket的魅力，并了解怎样去编写一个服务器，怎样通过Sockets连接到服务器，服务器怎样处理信息并将信息发送给相应的客户端。</p>
<p>不管你信不信，只要你用过PHP，就一定用过Sockets。HTTP服务器就是一个Socket服务器，浏览器就是客户端，也就是最简单的C/S模式。</p>
<h3 id="socket-">Socket基础知识</h3>
<p>我们可以把Socket当做是一种数据结构，客户端和服务器间通过这种数据结构来交换数据。服务器开始监听连接，当客户端想要连接服务器时，会通过服务器监听的端口开启一个会话，服务器收到客户端的请求后，建立连接完毕，然后继续监听下一次连接。</p>
<p>要产生一个Socket，你我们需要三个变量：一个协议（protocol）、一个socket类型（socket type）和一个公共协议类型（common protocol type）。下面将会详细介绍各个部分的具体内容。</p>
<p><strong>协议</strong></p>
<ul>
<li>AF_INET：这是大多数用来产生socket的协议，使用TCP或UDP来传输，用在IPv4的地址</li>
</ul>
<ul>
<li>AF_INET6：与上面类似，不过是来用在IPv6的地址</li>
</ul>
<ul>
<li>AF_UNIX：本地协议，使用在Unix和Linux系统上，它很少使用，一般都是当客户端和服务器在同一台及其上的时候使用</li>
</ul>
<p><strong>Socket类型</strong></p>
<ul>
<li>SOCK_STREAM：这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</li>
</ul>
<ul>
<li>SOCK_DGRAM：这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</li>
</ul>
<ul>
<li>SOCK_SEQPACKET：这个协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</li>
</ul>
<ul>
<li>SOCK_RAW：这个socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</li>
</ul>
<ul>
<li>SOCK_RDM：这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</li>
</ul>
<p><strong>公共协议</strong></p>
<ul>
<li>ICMP：互联网控制消息协议，主要使用在网关和主机上，用来检查网络状况和报告错误信息</li>
</ul>
<ul>
<li>UDP：用户数据报文协议，它是一个无连接，不可靠的传输协议</li>
</ul>
<ul>
<li>TCP：传输控制协议，这是一个使用最多的可靠的公共协议，它能保证数据包能够到达接受者那儿，如果在传输过程中发生错误，那么它将重新发送出错数据包。</li>
</ul>
<p>在PHP中我们使用socket_create()函数来产生一个Socket。socket_create()函数运行成功返回一个包含Socket的资源类型，如果没有成功则返回false。</p>
<p>1 resource socket_create(int protocol, int socketType, int commonProtocol);</p>
<p>PHP提供了很多操作Socket的函数。现在我们来看一个例子，了解PHP是如何产生、接受和监听一个socket。</p>
<pre><code>:::PHP
&lt;?php
$commonProtocol = getprotobyname(“tcp”);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, ‘localhost’, 1337);
socket_listen($socket);
// More socket functionality to come
?&gt;
</code></pre><p>我们来详细解释一下上面这个程序（基于行号）：</p>
<p>第二行：使用公共协议名字来获取一个协议类型。在这里使用的是TCP公共协议，如果你想使用UDP或者ICMP协议，就应该把getprotobyname()函数的参数改为“udp”或“icmp”。我们也可以不使用getprotobyname()函数而是直接指定SOL_TCP或SOL_UDP。</p>
<p>第三行：产生一个Socket并且返回一个Socket资源的实例。</p>
<p>第四行：有了一个Socket资源的实例以后，就必须把Socket绑定到一个IP地址和某一端口上。在这里绑定socket到本地计算机（127.0.0.1）的1337端口。</p>
<p>第五行：然后就需要监听所有进来的socket连接。</p>
<p>这时，我们就需要了解一下PHP中Socket函数的使用方法了。官方手册的介绍非常不错（<a href="http://www.php.net/manual/en/ref.sockets.php" target="_blank">猛戳这个链接</a>），下面只是简单列举几个最常用的。</p>
<ul>
<li>socket_accept() 接受一个Socket连接</li>
</ul>
<ul>
<li>socket_bind() 把socket绑定在一个IP地址和端口上</li>
</ul>
<ul>
<li>socket_close() 关闭一个socket资源</li>
</ul>
<ul>
<li>socket_connect() 开始一个socket连接</li>
</ul>
<ul>
<li>socket_create_listen() 在指定端口打开一个socket监听</li>
</ul>
<ul>
<li>socket_create() 产生一个socket，相当于产生一个socket的数据结构</li>
</ul>
<ul>
<li>socket_get_option() 获取socket选项</li>
</ul>
<ul>
<li>socket_getpeername() 获取远程主机的ip地址</li>
</ul>
<ul>
<li>socket_getsockname() 获取本地socket的ip地址</li>
</ul>
<ul>
<li>socket_listen() 监听由指定socket的所有连接</li>
</ul>
<ul>
<li>socket_read() 读取指定长度的数据</li>
</ul>
<ul>
<li>socket_readv() 读取从分散/聚合数组过来的数据</li>
</ul>
<ul>
<li>socket_recv() 从socket里结束数据到缓存</li>
</ul>
<ul>
<li>socket_recvfrom() 接受数据从指定的socket，如果没有指定则默认当前socket</li>
</ul>
<ul>
<li>socket_recvmsg() 从iovec里接受消息</li>
</ul>
<ul>
<li>socket_select() 多路选择</li>
</ul>
<ul>
<li>socket_send() 这个函数发送数据到已连接的socket</li>
</ul>
<ul>
<li>socket_sendmsg() 发送消息到socket</li>
</ul>
<ul>
<li>socket_sendto() 发送消息到指定地址的socket</li>
</ul>
<ul>
<li>socket_set_block() 在socket里设置为块模式</li>
</ul>
<ul>
<li>socket_set_nonblock() socket里设置为非块模式</li>
</ul>
<ul>
<li>socket_set_option() 设置socket选项</li>
</ul>
<ul>
<li>socket_shutdown() 这个函数允许你关闭读、写、或者指定的socket</li>
</ul>
<ul>
<li>socket_write() 写数据到socket缓存</li>
</ul>
<p>关于PHP Socket的基础知识就介绍到这里，还有不明白的可查看官方手册。下面介绍编写一个Socket服务器。</p>
<h3 id="-">编写服务器</h3>
<p>现在我们把第一个例子完善，使其能够监听一个指定的Socket并处理用户的连接。</p>
<pre><code>:::PHP
&lt;?php
$commonProtocol = getprotobyname(&quot;tcp&quot;);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, &#39;localhost&#39;, 1337);
socket_listen($socket);
// Accept any incoming connections to the server
$connection = socket_accept($socket);
if($connection)
{
   socket_write($connection, &quot;You have connected to the socket...\n\r&quot;);
}
?&gt;
</code></pre><p>注意这不是一个Web页面，如果你尝试使用Web浏览器来运行这个脚本，那么很有可能它会超过PHP运行30秒的限时。当然你可以使用下面的代码来设置一个无限的运行时间</p>
<blockquote>
<p>set_time_limit(0);</p>
</blockquote>
<p>但最好的办法还是直接使用命令提示符来运行：</p>
<blockquote>
<p>php server.php</p>
</blockquote>
<p>但截至目前，上面的服务器端有<strong>三个问题</strong>：</p>
<ol>
<li>它不能接受多个连接。</li>
</ol>
<ol>
<li>它只完成唯一的一个命令。</li>
</ol>
<ol>
<li>你不能通过Web浏览器连接这个服务器。</li>
</ol>
<p>在上一个代码的基础上再改进，使用下面的代码来做新服务器端：</p>
<pre><code>:::PHP
&lt;?php
// Set up our socket 
$commonProtocol = getprotobyname(&quot;tcp&quot;);
$socket = socket_create(AF_INET, SOCK_STREAM, $commonProtocol);
socket_bind($socket, &#39;localhost&#39;, 1337);
socket_listen($socket);
// Initialize the buffer 
$buffer = &quot;NO DATA&quot;;
while(true)
{
    // Accept any connections coming in on this socket
    $connection = socket_accept($socket);
    printf(&quot;Socket connected\r\n&quot;);
    // Check to see if there is anything in the buffer
    if($buffer != &quot;&quot;)
    {
        printf(&quot;Something is in the buffer...sending data...\r\n&quot;);
        socket_write($connection, $buffer . &quot;\r\n&quot;);
        printf(&quot;Wrote to socket\r\n&quot;);
    }
    else
    {
        printf(&quot;No Data in the buffer\r\n&quot;);
    }
    // Get the input
    while($data = socket_read($connection, 1024, PHP_NORMAL_READ))
    {
        $buffer = $data;
        socket_write($connection, &quot;Information Received\r\n&quot;);
        printf(&quot;Buffer: &quot; . $buffer . &quot;\r\n&quot;);
    }
    socket_close($connection);
    printf(&quot;Closed the socket\r\n\r\n&quot;);
}
?&gt;
</code></pre><p>这段程序初始化一个socket并且打开一个缓冲区收发数据。然后服务器开始等待连接，此时一旦产生一个连接，服务器将打印“Socket connected”。然后服务器检查缓冲区，如果缓冲区里有数据，服务器就把这些数据发送到连接的计算机客户端。然后服务器等待接收信息，并把接收到的信息保存，然后让连接的客户端知道信息接收成功后，服务器将关闭连接。连接关闭后，服务器将开始下一次处理连接的循环。</p>
<h3 id="-">编写客户端</h3>
<p>解决上面提到的第二个问题还是比较容易的。我们需要一个连接到服务器的页面来处理数据并发送到服务器。</p>
<p>我们来看下面的代码：</p>
<pre><code>:::PHP
&lt;?php
// Create the socket and connect 
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
$connection = socket_connect($socket,’localhost’, 1337);
while($buffer = socket_read($socket, 1024, PHP_NORMAL_READ))
{
    if($buffer == “NO DATA”)
    {
        echo(“&lt;p&gt;NO DATA&lt;/p&gt;”);
        break;
    }
    else
    {
        // Do something with the data in the buffer 
        echo(“&lt;p&gt;Buffer Data: “ . $buffer . “&lt;/p&gt;”);
    }
}
echo(“&lt;p&gt;Writing to Socket&lt;/p&gt;”);
// Write some test data to our socket
if(!socket_write($socket, “SOME DATA\r\n”))
{
    echo(“&lt;p&gt;Write failed&lt;/p&gt;”);
}
// Read any response from the socket
while($buffer = socket_read($socket, 1024, PHP_NORMAL_READ))
{
    echo(“&lt;p&gt;Data sent was: SOME DATA&lt;br&gt; Response was:” . $buffer . “&lt;/p&gt;”);
}
echo(“&lt;p&gt;Done Reading from Socket&lt;/p&gt;”);
?&gt;
</code></pre><p>这个例子的客户端连接到服务器后，客户端读取数据。如果这是客户端第一次连接服务器，服务器将发送“NO DATA”给客户端。如果客户端收到“NO DATA”说明其连接成功，客户端发送它的数据到服务器并等待服务器响应。一旦客户端接收到服务器的响应，客户端将把响应内容输出到屏幕上。</p>
<h3 id="-">总结</h3>
<p>如果还想深入了解PHP Socket，建议阅读更多的第三方资料或到PHP官方查询官方文档。今天就介绍到这里，如果有错误欢迎指正。</p>
<p>参考资料：《PHP Game Programming》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-04-15T06:21:50.000Z"><a href="/2012/04/15/html5-websocket-communication-protocol/">Apr 15 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/04/15/html5-websocket-communication-protocol/">HTML5 之 WebSocket 通信协议介绍</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>更新：Chrome和Firefox的WebSocket协议已更新到最新版，不再支持旧版协议。关于新版协议的介绍请看<a href="http://www.hackecho.com/" target="_blank">《WebSocket新版Hybi-10协议介绍》</a>，本篇文章中的握手协议和数据报文已不再适用。</strong></p>
<p>最近参与一个有关HTML5的比赛，要用到WebSocket，经过一些实验后简单总结一下WebSocket的基础用法。</p>
<p>WebSocket是HTML5的一种新的协议，它是实现了浏览器与服务器的双向通讯。</p>
<p>在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。（这两小段介绍摘自维基百科）</p>
<h3 id="websocket-">WebSocket协议</h3>
<p>WebSocket的协议非常简单，这也是其最大的优点之一。</p>
<p>在客户端（如浏览器），可以利用JavaScript直接new WebSocket来实例化一个WebSocket对象，其参数格式为ws://yourdomain:port/path。WebSocket会根据这段字符串，发送Header到指定服务器端口，其数据格式大概如下：</p>
<pre><code>GET / HTTP/1.1
Origin: http://hackecho.com 
Cookie: __utma=99as
Connection: Upgrade
Host: hackecho.com
Sec-WebSocket-Key: uRovscZjNol/umbTt5uKmw==
Upgrade: websocket Sec-WebSocket-Version: 13
</code></pre><p>此时服务端应该返回的信息是：</p>
<pre><code>HTTP/1.    WebSocket Protocol Handshake
Date: Fri,     Feb     17:38:    GMT
Connection: Upgrade
Server: HackEcho Server
Upgrade: WebSocket
Access-Control-Allow-Origin: http://hackecho.com 
Access-Control-Allow-Credentials: true
Sec-WebSocket-Accept: rLHCkw/SKsO9GAH/ZSFhBATDKrU=
Access-Control-Allow-Headers: content-type
</code></pre><p>一旦握手成功建立连接，数据便可以通过WebSocket在服务器和客户端之间进行传送了。</p>
<h3 id="websocket-">WebSocket事件</h3>
<p><a href="/images/2012/04/events-500x250.jpg"><img src="/images/2012/04/events-500x250.jpg" alt=""></a></p>
<p>客户端在握手成功后，会触发WebSocket对象的onopen事件，告诉客户端连接已经成功建立了。</p>
<p>客户端的WebSocket对象一共绑定了四个事件：</p>
<p>1、onopen：连接建立时触发；</p>
<p>2、onmessage：收到服务端消息时触发；</p>
<p>3、onerror：连接出错时触发；</p>
<p>4、onclose：连接关闭时触发；</p>
<h3 id="-">客户端连接的建立</h3>
<p>这里提供一个例子来更好地理解客户端是怎样建立WebSocket连接的。例子来自于文末参考资料的第一篇文章。</p>
<p>将下列代码保存为一个html文件，如websocket.html，在浏览器中打开。页面会自动向服务器（由<a href="http://www.websocket.org提供）连接，发送一个消息并将返回的结果显示出来，最后断开连接。" target="_blank">http://www.websocket.org提供）连接，发送一个消息并将返回的结果显示出来，最后断开连接。</a></p>
<p>通过其中的JavaScript代码即可看出用JS在本地建立连接的所有过程，比较简单，不再赘述，请大家看代码。</p>
<p>（不知怎么回事，如果去掉行号的代码缩进会乱掉，所以只能带上行号... 网上有很多去行号方法，大家可以Google之。）</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;title&gt;
    WebSocket Test
&lt;/title&gt;
&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
    var wsUri = &quot;ws://echo.websocket.org/&quot;;
    var output;
    function init() {
        output = document.getElementById(&quot;output&quot;);
        testWebSocket();
    }
    function testWebSocket() {
        websocket = new WebSocket(wsUri);
        websocket.onopen = function(evt) {
            onOpen(evt)
        };
        websocket.onclose = function(evt) {
            onClose(evt)
        };
        websocket.onmessage = function(evt) {
            onMessage(evt)
        };
        websocket.onerror = function(evt) {
            onError(evt)
        };
    }
    function onOpen(evt) {
        writeToScreen(&quot;CONNECTED&quot;);
        doSend(&quot;WebSocket rocks&quot;);
    }
    function onClose(evt) {
        writeToScreen(&quot;DISCONNECTED&quot;);
    }
    function onMessage(evt) {
        writeToScreen(&#39;&lt;span style=&quot;color: blue;&quot;&gt;RESPONSE: &#39; + evt.data + &#39;&lt;/span&gt;&#39;);
        websocket.close();
    }
    function onError(evt) {
        writeToScreen(&#39;&lt;span style=&quot;color: red;&quot;&gt;ERROR:&lt;/span&gt; &#39; + evt.data);
    }
    function doSend(message) {
        writeToScreen(&quot;SENT: &quot; + message);
        websocket.send(message);
    }
    function writeToScreen(message) {
        var pre = document.createElement(&quot;p&quot;);
        pre.style.wordWrap = &quot;break-word&quot;;
        pre.innerHTML = message;
        output.appendChild(pre);
    }
    window.addEventListener(&quot;load&quot;, init, false);
&lt;/script&gt;
&lt;h2&gt;
    WebSocket Test
&lt;/h2&gt;
&lt;div id=&quot;output&quot;&gt;
&lt;/div&gt;

&lt;/html&gt;
</code></pre><h3 id="-">服务器端的实现</h3>
<p>在将WebSocket应用到实际中时，我们往往需要自己的服务器来响应各种请求以实现更加丰富的功能。从前面的协议介绍部分来看，实现一个WebSocket服务器端并不难。但本着“不重复制造轮子”的原则，我们将基于开源的<a href="http://code.google.com/p/phpwebsocket/" target="_blank">PHPWebSocket Project</a>来二次开发自己的服务器。PHPWebSocket Project中已实现握手协议部分，其它的功能将可以由我们自由添加。这里只讨论握手协议部分和一个简单的响应函数。</p>
<p>将下列代码保存为server.php文件：</p>
<pre><code>&lt;?php
error_reporting(E_ALL);
set_time_limit(0);
ob_implicit_flush();

$master  = WebSocket(&quot;localhost&quot;,12345);
$sockets = array($master);
$users   = array();
$debug   = false;

while(true){
    $changed = $sockets;
    socket_select($changed,$write=NULL,$except=NULL,NULL);
    foreach($changed as $socket){
        if($socket==$master){
            $client=socket_accept($master);
            if($client&lt;0){ console(&quot;socket_accept() failed&quot;); continue; }
            else{ connect($client); }
        }
        else{
            $bytes = @socket_recv($socket,$buffer,2048,0);
            if($bytes==0){ disconnect($socket); }
            else{
                $user = getuserbysocket($socket);
                if(!$user-&gt;handshake){ dohandshake($user,$buffer); }
                else{ process($user,$buffer); }
            }
        }
    }
}

//---------------------------------------------------------------
function process($user,$msg){
    $action = unwrap($msg);
    say(&quot;&lt; &quot;.$action);
    send($user-&gt;socket,&quot;lzy &quot;.$action);
}

function send($client,$msg){
    say(&quot;&gt; &quot;.$msg);
    $msg = wrap($msg);
    socket_write($client,$msg,strlen($msg));
}

function WebSocket($address,$port){
    $master=socket_create(AF_INET, SOCK_STREAM, SOL_TCP)     or die(&quot;socket_create() failed&quot;);
    socket_set_option($master, SOL_SOCKET, SO_REUSEADDR, 1)  or die(&quot;socket_option() failed&quot;);
    socket_bind($master, $address, $port)                    or die(&quot;socket_bind() failed&quot;);
    socket_listen($master,20)                                or die(&quot;socket_listen() failed&quot;);
    echo &quot;Server Started : &quot;.date(&#39;Y-m-d H:i:s&#39;).&quot;\n&quot;;
    echo &quot;Master socket  : &quot;.$master.&quot;\n&quot;;
    echo &quot;Listening on   : &quot;.$address.&quot; port &quot;.$port.&quot;\n\n&quot;;
    return $master;
}

function connect($socket){
    global $sockets,$users;
    $user = new User();
    $user-&gt;id = uniqid();
    $user-&gt;socket = $socket;
    array_push($users,$user);
    array_push($sockets,$socket);
    console($socket.&quot; CONNECTED!&quot;);
}

function disconnect($socket){
    global $sockets,$users;
    $found=null;
    $n=count($users);
    for($i=0;$i&lt;$n;$i++){
        if($users[$i]-&gt;socket==$socket){ $found=$i; break; }
    }
    if(!is_null($found)){ array_splice($users,$found,1); }
    $index = array_search($socket,$sockets);
    socket_close($socket);
    console($socket.&quot; DISCONNECTED!&quot;);
    if($index&gt;=0){ array_splice($sockets,$index,1); }
}

function dohandshake($user,$buffer){
    console(&quot;\nRequesting handshake...&quot;);
    console($buffer);
    list($resource,$host,$origin,$strkey1,$strkey2,$data) = getheaders($buffer);
    console(&quot;Handshaking...&quot;);

    $pattern = &#39;/[^\d]*/&#39;;
    $replacement = &#39;&#39;;
    $numkey= preg_replace($pattern, $replacement, $strkey1);
    $numkey= preg_replace($pattern, $replacement, $strkey2);

    $pattern = &#39;/[^ ]*/&#39;;
    $replacement = &#39;&#39;;
    $spaces= strlen(preg_replace($pattern, $replacement, $strkey1));
    $spaces= strlen(preg_replace($pattern, $replacement, $strkey2));

    if ($spaces== || $spaces== || $numkey% $spaces!= || $numkey% $spaces!= 0) {
        socket_close($user-&gt;socket);
        console(&#39;failed&#39;);
        return false;
    }

    $ctx = hash_init(&#39;md5&#39;);
    hash_update($ctx, pack(&quot;N&quot;, $numkey1/$spaces1));
    hash_update($ctx, pack(&quot;N&quot;, $numkey2/$spaces2));
    hash_update($ctx, $data);
    $hash_data = hash_final($ctx,true);

    $upgrade  = &quot;HTTP/1.WebSocket Protocol Handshake\r\n&quot; .
    &quot;Upgrade: WebSocket\r\n&quot; .
    &quot;Connection: Upgrade\r\n&quot; .
    &quot;Sec-WebSocket-Origin: &quot; . $origin . &quot;\r\n&quot; .
    &quot;Sec-WebSocket-Location: ws://&quot; . $host . $resource . &quot;\r\n&quot; .
    &quot;\r\n&quot; .
    $hash_data;

    socket_write($user-&gt;socket,$upgrade.chr(0),strlen($upgrade.chr(0)));
    $user-&gt;handshake=true;
    console($upgrade);
    console(&quot;Done handshaking...&quot;);
    return true;
}

function getheaders($req){
    $r=$h=$o=null;
    if(preg_match(&quot;/GET (.*) HTTP/&quot;   ,$req,$match)){ $r=$match[1]; }
    if(preg_match(&quot;/Host: (.*)\r\n/&quot;  ,$req,$match)){ $h=$match[1]; }
    if(preg_match(&quot;/Origin: (.*)\r\n/&quot;,$req,$match)){ $o=$match[1]; }
    if(preg_match(&quot;/Sec-WebSocket-Key2: (.*)\r\n/&quot;,$req,$match)){ $key2=$match[1]; }
    if(preg_match(&quot;/Sec-WebSocket-Key1: (.*)\r\n/&quot;,$req,$match)){ $key1=$match[1]; }
    if(preg_match(&quot;/\r\n(.*?)\$/&quot;,$req,$match)){ $data=$match[1]; }
    return array($r,$h,$o,$key1,$key2,$data);
}

function getuserbysocket($socket){
    global $users;
    $found=null;
    foreach($users as $user){
        if($user-&gt;socket==$socket){ $found=$user; break; }
    }
    return $found;
}

function     say($msg=&quot;&quot;){ echo $msg.&quot;\n&quot;; }
function    wrap($msg=&quot;&quot;){ return chr(0).$msg.chr(255); }
function  unwrap($msg=&quot;&quot;){ return substr($msg,1,strlen($msg)-2); }
function console($msg=&quot;&quot;){ global $debug; if($debug){ echo $msg.&quot;\n&quot;; } }

class User{
    var $id;
    var $socket;
    var $handshake;
}

?&gt;
</code></pre><p>运行php server.php命令启动服务器，这时服务器启动。</p>
<p>然后我们将下列代码保存为client.html文件：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;WebSocket&lt;/title&gt;

&lt;style&gt;
html,body{font:normal 0.9em arial,helvetica;}
#log {width:440px; height:200px; border:1px solid #7F9DB9; overflow:auto;}
#msg {width:330px;}
&lt;/style&gt;

&lt;script&gt;
var socket;

function init(){
    var host = &quot;ws://localhost:12345/websocket/server.php&quot;;
    try{
        socket = new WebSocket(host);
        log(&#39;WebSocket - status &#39;+socket.readyState);
        socket.onopen    = function(msg){ log(&quot;Welcome - status &quot;+this.readyState); };
        socket.onmessage = function(msg){ log(&quot;Received: &quot;+msg.data); };
        socket.onclose   = function(msg){ log(&quot;Disconnected - status &quot;+this.readyState); };
    }
    catch(ex){ log(ex); }
    $(&quot;msg&quot;).focus();
}

function send(){
    var txt,msg;
    txt = $(&quot;msg&quot;);
    msg = txt.value;
    if(!msg){ alert(&quot;Message can not be empty&quot;); return; }
    txt.value=&quot;&quot;;
    txt.focus();
    try{ socket.send(msg); log(&#39;Sent: &#39;+msg); } catch(ex){ log(ex); }
}
function quit(){
    log(&quot;Goodbye!&quot;);
    socket.close();
    socket=null;
}

// Utilities
function $(id){ return document.getElementById(id); }
function log(msg){ $(&quot;log&quot;).innerHTML+=&quot;&lt;br&gt;&quot;+msg; }
function onkey(event){ if(event.keyCode==13){ send(); } }
&lt;/script&gt;

&lt;/head&gt;
&lt;body onload=&quot;init()&quot;&gt;
&lt;h3&gt;WebSocket v2.00&lt;/h3&gt;
&lt;div id=&quot;log&quot;&gt;&lt;/div&gt;
&lt;input id=&quot;msg&quot; type=&quot;textbox&quot; onkeypress=&quot;onkey(event)&quot;/&gt;
&lt;button onclick=&quot;send()&quot;&gt;Send&lt;/button&gt;
&lt;button onclick=&quot;quit()&quot;&gt;Quit&lt;/button&gt;
&lt;div&gt;Commands: hello, hi, name, age, date, time, thanks, bye&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这时在浏览器中打开client.html，即可实现一个简单的通过WebSocket连接到本地服务器然后发送消息、响应消息的应用。</p>
<p>有兴趣的读者可以继续阅读以下参考资料：</p>
<h3 id="-">参考资料：</h3>
<p><a href="http://www.websocket.org/echo.html" target="_blank">《WebSocket Echo Test》</a></p>
<p><a href="http://www.zendstudio.net/archives/websocket-protocol/" target="_blank">《websocket 通信协议》</a></p>
<p><a href="http://blog.bingo929.com/html5-websockets.html" target="_blank">《HTML5 WebSockets 基础使用教程》</a></p>
<p><a href="http://zh.wikipedia.org/zh-cn/WebSocket" target="_blank">《WikiPedia WebSocket》</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hackecho.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2013/10/20/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a>
      </li>
    
      <li>
        <a href="/2013/04/24/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a>
      </li>
    
      <li>
        <a href="/2013/04/10/basics-of-mpi/">MPI 并行程序设计基础</a>
      </li>
    
      <li>
        <a href="/2013/03/21/a-letter-to-myself/">写给四年前刚开始编程的自己</a>
      </li>
    
      <li>
        <a href="/2013/03/04/basic-of-gcc/">GCC 基础</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
<li><a href="http://vicdory.com/" title="Kailun Shi">Kailun Shi</a></li>
</ul>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Android,AsyncTask/">Android,AsyncTask</a><small>1</small></li>
  
    <li><a href="/tags/Android,SharedPreferences/">Android,SharedPreferences</a><small>1</small></li>
  
    <li><a href="/tags/BidData/">BidData</a><small>1</small></li>
  
    <li><a href="/tags/Decorator,Python/">Decorator,Python</a><small>1</small></li>
  
    <li><a href="/tags/GBK,Mac,UTF8/">GBK,Mac,UTF8</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Google+/">Google+</a><small>1</small></li>
  
    <li><a href="/tags/JSON,XML,PHP/">JSON,XML,PHP</a><small>1</small></li>
  
    <li><a href="/tags/Life/">Life</a><small>1</small></li>
  
    <li><a href="/tags/Linux,HFS/">Linux,HFS</a><small>1</small></li>
  
    <li><a href="/tags/MPI/">MPI</a><small>1</small></li>
  
    <li><a href="/tags/MVC, PHP/">MVC, PHP</a><small>1</small></li>
  
    <li><a href="/tags/PHP,Socket/">PHP,Socket</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>1</small></li>
  
    <li><a href="/tags/ThinkPHP/">ThinkPHP</a><small>1</small></li>
  
    <li><a href="/tags/WebSocket,HTML5/">WebSocket,HTML5</a><small>1</small></li>
  
    <li><a href="/tags/Wordpress/">Wordpress</a><small>2</small></li>
  
    <li><a href="/tags/boost,thread/">boost,thread</a><small>1</small></li>
  
    <li><a href="/tags/cuda,parallel,reduction/">cuda,parallel,reduction</a><small>1</small></li>
  
    <li><a href="/tags/fly-of-promgrammer/">fly-of-promgrammer</a><small>1</small></li>
  
    <li><a href="/tags/gcc/">gcc</a><small>1</small></li>
  
    <li><a href="/tags/ipc,semaphores/">ipc,semaphores</a><small>1</small></li>
  
    <li><a href="/tags/life/">life</a><small>1</small></li>
  
    <li><a href="/tags/makefile/">makefile</a><small>1</small></li>
  
    <li><a href="/tags/movie/">movie</a><small>1</small></li>
  
    <li><a href="/tags/open source/">open source</a><small>1</small></li>
  
    <li><a href="/tags/pthread/">pthread</a><small>1</small></li>
  
    <li><a href="/tags/web/">web</a><small>1</small></li>
  
    <li><a href="/tags/websocket/">websocket</a><small>1</small></li>
  
    <li><a href="/tags/极客/">极客</a><small>1</small></li>
  
    <li><a href="/tags/程序员/">程序员</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Zhaoyu Li
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'hackecho';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>