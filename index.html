<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hackecho</title>
  <meta name="author" content="Zhaoyu Li">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hackecho"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hackecho" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hackecho</a></h1>
  <h2><a href="/">Blog by Zhaoyu Li</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-04-16T04:23:00.000Z"><a href="/2014/04/hadoop-cluster-setup-instruction-with-fedora-20/">Apr 15 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/04/hadoop-cluster-setup-instruction-with-fedora-20/">Hadoop Cluster Setup Instruction with Fedora 20</a></h1>
  

    </header>
    <div class="entry">
      
        <p>It is easy to setup a Hadoop cluster using Fedora 20, basically you need several steps.</p>
<ol>
<li>Fedora 20 installation</li>
<li>Basic configuration</li>
<li>SSH without password</li>
<li>Hadoop package and related packages installation</li>
<li>Hadoop configuration</li>
<li>Start the cluster</li>
<li>How to add a new datanode</li>
</ol>
<h2 id="1-fedora-20-installation">1. Fedora 20 installation</h2>
<p>If your machine is x32, you need to download the installation image for x32, which is ‘i386 DVD’. The image can be got from <a href="http://fedoraproject.org/en_GB/get-fedora-all" target="_blank">this link</a>.</p>
<p>During the installation, let us create a admin user <code>‘hadoop’</code>.</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2014/04/hadoop-cluster-setup-instruction-with-fedora-20/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-20T19:23:03.000Z"><a href="/2013/10/real-time-emotion-analysis-on-twitter/">Oct 20 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a></h1>
  

    </header>
    <div class="entry">
      
        <p>This post is about my project of Big Data course. Also, you can view the online version via this link: <a href="https://drive.google.com/file/d/0B1e8KyDeJL60LVhwbzl2cDMyMEE/edit?usp=sharing" target="_blank">Online version</a></p>
<h2 id="basic-concept">Basic Concept</h2>
<p>We use real-time big data analysis technologies to evaluate tweets about some brands and products. We will judge the emotion of tweets and decide if the tweet expresses positive, negative or no emotion about a specific brand or product. The company or merchant can observe the trend of customers’ emotion towards its brand or products, understand customers’ online behavior or re- action, based on which they can make better decisions and provide better services. This project will help companies find out what their customers feel and adjust their marketing strategies timely.</p>
<h2 id="smarter-planet-information">Smarter Planet Information</h2>
<p>When a company release its new products, the managers of this company must want to know what are people’s opinions about their products, or how their customers feel when they use their products. In this way, they can get people’s online reaction quickly and make better decisions onwards. Nowadays, thanks to the development of social network, it becomes true.</p>
<p>When customers use a product, they probably have some feelings, such as happy or hate. In old days, they could just communicate with people around them. However, today, they can post their feelings on social network, and instantly his fiends around the world can see it. Then maybe some of his friends will re-post it and more people will see it. The social network changes the way information spread and lead us to a new era of information.</p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2013/10/real-time-emotion-analysis-on-twitter/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-04-25T04:57:00.000Z"><a href="/2013/04/cuda-parallel-reduction/">Apr 24 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/04/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Parallel Reduction是NVIDIA-CUDA自带的例子，也几乎是所有CUDA学习者的的必看算法。在这个算法的优化中，Mark Harris为我们实现了7种不同的优化版本，将Bandwidth几乎提高到了峰值。相信我们通过仔细研读这个过程，一定能对CUDA程序的优化有更加深刻的认识。下面我们来一一细看这几种优化方案，<strong>数据和思想均摘录自官方SDK中Samples的算法说明</strong>。</p>
<h3 id="parallel-reduction">Parallel Reduction</h3>
<p>Parallel Reduction可以理解为将一个数组中的所有数相加求和的过程并行化。一般来讲，我们并行化的思路是基于“树”的二元规约，如下图：</p>
<p><a href="/images/2013/04/parallel_reduction_tree_based.png"><img src="/images/2013/04/parallel_reduction_tree_based.png" alt=""></a></p>

      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2013/04/cuda-parallel-reduction/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-04-10T22:27:00.000Z"><a href="/2013/04/basics-of-mpi/">Apr 10 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/04/basics-of-mpi/">MPI 并行程序设计基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p>有两门课的作业要用到MPI，“高性能计算环境”和“并行与分布式系统”，所以简单了解了一下MPI的基础知识。MPI并不是并行程序设计的唯一方法，但却是一种行之有效的方法。而且MPI已在几乎所有主流的并行机上得到实现，具有很高的可移植性，适用范围非常广泛。这是一篇学习笔记，因此不会面面俱到。</p>
<h3 id="-mpi">什么是MPI</h3>
<p>MPI是Massage Passing Interface的简写，是消息传递函数库的标准规范，由MPI论坛开发，支持Fortran和C，主要用于进程（Process）间通信。</p>
<p>在MPI中，数据被显式由从一个进程发送给另一个进程，一个称为发送方，一个称为接收方。</p>
<h3 id="hello-world">Hello World</h3>
<p>让我们从一个最简单的MPI Hello World程序开始。</p>
<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
int main( int argc, char *argv[] )
{
    MPI_Init( &amp;argc, &amp;argv );
    printf( &quot;Hello, world!\n&quot; );
    MPI_Finalize();
    return 0;
}
</code></pre><p>Notes:</p>
<ol>
<li><p>必须包含 <code>mpi.h</code> 头文件；</p>
</li>
<li><p>MPI函数返回出错代码或 <code>MPI_SUCCESS</code> .</p>
</li>
</ol>
<p>编译并运行我们的程序（关于编译和运行本文后面有详细介绍）：</p>
<pre><code>$ mpicc -o hello hello.c
$ mpirun -np 4 hello
Hello World!
Hello World!
Hello World!
Hello World!
</code></pre><h3 id="mpi-">MPI程序基础结构</h3>
<h4 id="-">执行流程</h4>
<p>MPI程序的结构如下图所示：</p>
<p><a href="/images/2013/04/mpi_structure.png"><img src="/images/2013/04/mpi_structure.png" alt=""></a></p>
<p><strong>MPI初始化</strong></p>
<pre><code>:::BASH
int MPI_Init(int *argc, char **argv)
</code></pre><p>MPI_Init 是MPI程序的第一个调用，它完成MPI程序的所有初始化工作，启动MPI环境，标志并行代码的开始。</p>
<p><strong>MPI结束</strong></p>
<pre><code>:::BASH
int MPI_Finalize(void)
</code></pre><p>MPI_Finalize 是MPI程序的最后一个调用，它结束MPI程序的运行，标志并行代码的结束，结束除主进程外其它进程。其之后串行代码仍可在主进程(rank = 0)上继续运行。</p>
<p>在写MPI程序时，我们常需要知道以下两个问题的答案：</p>
<ul>
<li><p>任务由<code>多少</code>个进程来进行并行计算(How many processes are participating in this computation)？</p>
</li>
<li><p>我是<code>哪一个</code>进程(Which one am I)？</p>
</li>
</ul>
<p>MPI提供了下列函数来回答这些问题：</p>
<p><strong>MPI_Comm_size</strong></p>
<p>MPI用 <code>MPI_Comm_size</code> 获得进程个数 p</p>
<pre><code>:::C
int MPI_Comm_size(MPI_Comm comm, int *size);
</code></pre><p><strong>MPI_Comm_rank</strong></p>
<p>MPI用 <code>MPI_Comm_rank</code> 获得进程的一个叫rank的值，该rank值为 0 到 p-1 间的整数，相当于进程的ID。</p>
<pre><code>:::C
int MPI_Comm_rank(MPI_Comm comm, int *rank);
</code></pre><p>下面我们用改进版的Hello World来看一下其用法：</p>
<pre><code>:::C
#include &lt;stdio.h&gt;
#include &quot;mpi.h&quot;
int main( int argc, char *argv[] )
{
    int rank, size;
    MPI_Init( &amp;argc, &amp;argv );
    MPI_Comm_rank( MPI_COMM_WORLD, &amp;rank );
    MPI_Comm_size( MPI_COMM_WORLD, &amp;size );
    printf(&quot;I am %d of %d\n&quot;, rank, size );
    MPI_Finalize();
    return 0;
}
</code></pre><p>运行结果：</p>
<pre><code>:::BASH
$ mpicc –o hello hello.c
$ mpirun -np 4 hello
I am 0 of 4
I am 1 of 4
I am 2 of 4
I am 3 of 4
</code></pre><h4 id="-">消息发送和接受</h4>
<p>MPI消息的发送和接收模型如下：</p>
<p><a href="/images/2013/04/mpi_msg.png"><img src="/images/2013/04/mpi_msg.png" alt=""></a></p>
<p>消息由一个进程发送给另一进程。在这个过程中，我们需要明确一下问题：</p>
<ul>
<li><p><code>data</code>怎样表示？</p>
</li>
<li><p>怎样标识进程？</p>
</li>
<li><p>这个过程有什么后果？</p>
</li>
</ul>
<p>让我们通过一个程序来学习消息的发送与接收。</p>
<pre><code>:::C
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;mpi.h&quot;

int main(int argc,char *argv[])
{
    int numprocs, myid, source; 
    MPI_Status status;
    char message[100];
    MPI_Init(&amp;argc, &amp;argv); 
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid); 
    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);
    if(myid!=0)
    {
        sprintf(message, &quot;Greetings from process %d!&quot;,myid);
        MPI_Send(message,strlen(message)+1, MPI_CHAR, 0, 99, MPI_COMM_WORLD);
    } 
    else 
    {   /* myid == 0 */
        for (source = 1; source &lt; numprocs; source++) {
            MPI_Recv(message, 100, MPI_CHAR, source, 99, MPI_COMM_WORLD, &amp;status);
            printf(&quot;%s\n&quot;, message);
        }
    }
    MPI_Finalize();
    return 0;
}
</code></pre><p>说明：</p>
<p><strong>通信空间: MPI_COMM_WORLD</strong></p>
<p>多个进程可以形成组(group)，一个信息的发送和接收都必须在同一个命名空间(context)，一个组和命名空间一起形成一个通信空间(communicator)。<code>MPI_COMM_WORLD</code> 是一个默认的通信空间，它的组包含了程序的所有初始进程。</p>
<p><strong>Point to Point</strong></p>
<p>即单个进程对单个进程的通信，分为阻塞和非阻塞两种方式：</p>
<ol>
<li><p><code>Blocking(阻塞)</code> ：一个例程须等待操作完成才返回，返回后用户可以重新使用调用中所占用的资源。</p>
</li>
<li><p><code>Non-blocking(非阻塞)</code> ：一个例程不必等待操作完成便可返回，但这并不意味着所占用的资源可被重用。</p>
</li>
</ol>
<p><strong>发送消息(阻塞)</strong></p>
<pre><code>:::C
int MPI_Send(void* buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm);
</code></pre><p>其中，</p>
<pre><code>:::BASH
IN buf      :发送缓冲区的起始地址
IN count    :要发送信息的元素个数
IN datatype :发送信息的数据类型
IN dest     :目标进程的rank值
IN tag      :消息标签
IN comm     :通信空间
</code></pre><p>当此函数返回时，数据已经到达系统，buffer可以重新使用，但此时信息不一定已经被目标进程完成接收。</p>
<p><strong>接受消息(阻塞)</strong></p>
<pre><code>:::C
int MPI_Recv(void* buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status);
</code></pre><p>其中，</p>
<pre><code>:::BASH
OUT buf     :接收缓冲区的起始地址
IN count    :要接收信息的元素个数
IN datatype :接收信息的数据类型
IN source   :源进程的rank值
IN tag      :消息标签
IN comm     :通信空间
OUT status  :status对象，包含实际接收到的消息的有关信息
</code></pre><p>当此函数返回时，数据已经被目标进程从系统接收完成，buffer可以重新使用。</p>
<p><strong>消息匹配</strong></p>
<p>MPI消息包括 <code>信封</code> 和 <code>数据</code> 两个部分， <code>信封</code> 指发送或接收消息的对象及相关信息，而 <code>数据</code> 是这个消息将要传递的内容。</p>
<pre><code>:::BASH
MPI_Send(buf, count, datatype, dest, tag, comm)
          |     |        |       |    |     |
          ----- 数据 -----        --- 信封 ---

MPI_Recv(buf, count, datatype, source, tag, comm, *status)
          |     |        |       |    |      |
          ----- 数据 -----        --- 信封 ----
</code></pre><p>接收buffer必须至少可以容纳count个由datatype参数指明类型的数据。如果接收buf太小，将导致溢出、出错。</p>
<p>接收方的Source可以为 <code>MPI_ANY_SOURCE</code> ，代表可以接收任意处理器来的数据(任意消息来源)；Tag可以为 <code>MPI_ANY_TAG</code> ，代表可以匹配任意tag值的消息(任意tag消息）。在阻塞式消息传送中不允许Source==Dest，否则会导致死锁。</p>
<p>至此，我们可以看出，上例中信息流的方向如下图所示：</p>
<p><a href="/images/2013/04/mpi_msgroute.png"><img src="/images/2013/04/mpi_msgroute.png" alt=""></a></p>
<h4 id="-">错误处理</h4>
<p>通常情况下，一个错误会导致所有的进程崩溃，为了避免，用户可以让子程序在出错时返回错误代码(在C++中可以抛出异常)，或者自定义错误处理函数等。</p>
<h4 id="-">更多信息</h4>
<p>我们可以使用接收函数中的 <code>status</code> 来接收更多信息。</p>
<pre><code>:::C
int recvd_tag, recvd_from, recvd_count;
MPI_Status status;
MPI_Recv(..., MPI_ANY_SOURCE, MPI_ANY_TAG, ..., &amp;status )
recvd_tag  = status.MPI_TAG;
recvd_from = status.MPI_SOURCE;
MPI_Get_count( &amp;status, datatype, &amp;recvd_count ); //返回实际接收到消息的长度
</code></pre><h4 id="-">编译和运行</h4>
<p>我们可以用 <code>mpicc</code> 编译并连接用C语言编写的MPI程序，或者使用 <code>mpiCC</code> 编译并连接用C++语言编写的MPI程序。用 <code>mpicc</code> 编译时，就像用一般的C编译器一样，可以使用一般的编译选项，用法与原来的编译器相同。编译完成后，我们可以使用 <code>mpirun –np N [program]</code> 运行程序，其中 <code>N</code> 为同时运行的进程数， <code>[program]</code> 为可执行程序的文件名。</p>
<p>除此之外，还有一些其它的运行方式，即从文件中读取配置。</p>
<pre><code>:::BASH
mpirun –p4pg [pgfile] [program]
</code></pre><p>其中， <code>[pgfile]</code> 为配置文件，其格式为:</p>
<pre><code>:::BASH
&lt;机器名&gt; &lt;进程数&gt; &lt;程序名&gt; 
&lt;机器名&gt; &lt;进程数&gt; &lt;程序名&gt; 
&lt;机器名&gt; &lt;进程数&gt; &lt;程序名&gt;
</code></pre><p>或者</p>
<pre><code>:::BASH
mpirun –machinefile [machinefile] -np [N] [program]
</code></pre><p>其中，<code>[machinefile]</code> 为配置文件，其格式为:</p>
<pre><code>:::BASH
&lt;机器名&gt; 
&lt;机器名&gt; 
&lt;机器名&gt;
</code></pre><h3 id="-">避免死锁</h3>
<p>为了避免死锁，尽量保持发送和接受成对出现。</p>
<p>不安全的通信调用：</p>
<pre><code>:::BASH
  Process 0      Process 1
----------------------------
   Send(1)        Send(0)
   Recv(1)        Recv(0)
</code></pre><p>安全的通信调用：</p>
<pre><code>:::BASH
  Process 0      Process 1
----------------------------
   Send(1)        Recv(0)
   Recv(1)        Send(0)
</code></pre><p>或者使用非阻塞调用：</p>
<pre><code>:::BASH
  Process 0      Process 1
----------------------------
   Isend(1)       Isend(0)
   Irecv(1)       Irecv(0)
   Waitall        Waitall
</code></pre><p>除此之外，还有很多知识点没有介绍，如果以后有机会，我会进行更深一步的探讨。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-21T21:49:00.000Z"><a href="/2013/03/a-letter-to-myself/">Mar 21 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a></h1>
  

    </header>
    <div class="entry">
      
        <p>2009年9月，进入大学的第一天，开始了我正式的软件工程的学习。为什么是正式的呢，因为之前虽然也写过代码，但完全是出于兴趣，想到什么就学什么，毫无章法。后来来到了北交大，进入了据说还不错的软件学院，有了一群志同道合的朋友，一位位用心良苦的老师，踏上了一个“程序员“的冒险旅程。现在，我在美国密苏里大学读计算机硕士，回首自己走过来的这四年，错过了很多，也明白了很多，收获了很多，对软件和计算机渐渐有了自己的认识，更重要的是，发现了自己越来越多的缺陷与不足。有些当年认为用处不大而忽略掉的东西，却成了现在最最重要的东西。有时会后悔地埋怨自己当时不努力，欠下了太多的债，只能后来慢慢偿还。</p>
<p>如果能够给我一次机会与四年前的我通话，我有太多的东西想对他说。然而，也许几年后再次回首，我会有另一番不同的思绪，但此时此景，我能想到这些，至少现在是对的，我不想后悔，把这些写下来，算是一种慰藉吧。</p>
<h3 id="-">多出去走走，开阔眼界</h3>
<p>“世界就像一本书，不旅行的人，只读过这本书里的一页。”</p>
<p>世界之大，无奇不有，不管你是否要做一个技术男，你都应该出去走走，去看更多的风景，去见更多的人，去体会更多的风情。不要做井底之蛙，这个世界到处都是精彩的事物，而有些东西如果不去亲自体会是永远无法得到的。没有人规定程序员就必须整天埋在代码中，上天赋予了程序员自由的职业特性，就一定要利用好它。程序本身就是一种美，你要时刻保持一颗欣赏美、涉猎美的心灵，才能更好地去发现和创造。眼界开阔了，心灵才不会收拘束。真的，这个世界太美好，去发现感动到哭的美。</p>
<p>你要做一个旅行家里代码写得最好的人！</p>
<h3 id="-">不要沉迷社交网络，线下的生活更加丰富</h3>
<p>碎片化的信息正在侵袭着我们的生活，社交网络的发明让我们能够在网上互动和交流。但你要问自己，这些真的对你有用处吗？当你和周围的朋友们沉迷于人人网微博消耗时间时，是否意识时间正在疯狂地消逝，等关闭网页的瞬间，你是否感觉到孤独感重新来袭。</p>
<p>最近刚看了《黑镜》第二季，第一集中男主人公沉迷于社交网络，有一天车祸不幸去世后，有人制作了一个机器人，根据他生前在社交网络上的言行，让他继续虚拟地活下去。当然结局你应该猜到了，是的，这个人没有情感，有些东西是永远无法从社交网络上模拟的。</p>
<p>线下的生活更精彩，你要多参加有益的社团、活动，多交朋友，在真实生活中维持真实的感情。</p>
<h3 id="-c-">打好C语言基础，掌握并深入一门编程语言</h3>
<p>在后来的学习中，尤其是这几个月来在国外的学习，让我渐渐感受到一些教育上的差异。C语言作为你正式学习的第一门语言，你要做到的不是掌握语法这么简单。语言是指一种工具，帮助你理解程序设计的思想和奥秘。如果有可能的话，我希望你开始研读Linux设计思想和源码，理解其中各种设计模型和理念，因为这些才是根，当你真正了理解了这些，就会发现所有的语言都是互通的，都遵循了一个准则，即使有新的思想，你也会很快接受并融会贯通的。</p>
<p>说到语言是工具，你当然要选择一门语言并试图做到精通。建议你学习C++，因为它更接近软件的底层和实质。掌握并精通它，理解它的一切，并在现有的基础上创新。Java封装的太多，你可以用Java来很好地理解面向对象的设计原则，来快速地开发一些程序，但Java会限制你的提高。当然你可以做一个Java界的大牛，但你想想，除非你特别喜欢这门语言，否则不要被它框住。</p>
<h3 id="-">一定要学好的课程，一定要读的书，一定要掌握的技术</h3>
<p>这几门课程是你一定要认真学习的，因为有一天你会发现它们非常重要：“数学方面的课程”、“数据结构”、“算法设计”、“操作系统”、“数据库”和“系统级编程”等。</p>
<p>这几本书不管你有多忙，都希望你能好好研读：《算法导论》，《代码大全》，《编程珠玑》外加多本文学书籍。</p>
<p>这几个技术一定要用心学习，因为它们真的很有用：Linux（内核+概念+应用），数据库，汇编与编译，调试，算法设计等。</p>
<h3 id="-">广泛涉猎，但不要丧失重心</h3>
<p>技术行业里永远有新的技术，不要让你的大脑僵化，要勇于去尝试新的东西，了解各个细分的行业，了解各项技术，广泛涉猎。因为只有这样，你才能发现什么是你真正喜欢的，真正感兴趣的。当你找到了自己真正的兴趣所在，你的所有研究和工作都将是快乐的。</p>
<p>另外，树立一个榜样，如果你决定要做一个商人，可以选择比尔盖茨、乔布斯，如果你决定要做研究，可以选择Linus，高德纳等技术流。抱着一种学习的心态去看待，不要盲目崇拜。</p>
<h3 id="-">好好学习一门脚本语言</h3>
<p>学习一门脚本语言如Python或Ruby。建议学习Python，并好好掌握它，这样可以让你更快速地与计算机交互，帮你快速解决某些问题。Python也有很多各方面的、优秀的框架，在Server开发、科学计算等方面都有很大的潜力。另外，PHP可以让你快速地架设一个小型网站，而且开源的系统也非常多。所有的这些工具，都可以在你需要的时候帮助到你。</p>
<h3 id="-">保持一颗好奇心，一颗童心</h3>
<p>时刻关注业界信息，关注各个IT公司动态，关注科技新闻，关注创业，向过来人吸取经验。你看得越多，分析的越多，你对业界的信息、发展的感知就会越敏锐。不要盲目跟风网上的言论，学会自己分析。</p>
<p>保持一颗童心，你才能保持一颗创造性的心，不要僵化思维，不要定势思维。这些都是需要训练的，相信你经过这些历练，一定可以有所进步。</p>
<p>最后，珍惜时间，珍惜生命，做最好的自己。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-04T16:18:00.000Z"><a href="/2013/03/basic-of-gcc/">Mar 4 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/basic-of-gcc/">GCC 基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p>GCC，糊里糊涂地用了好长时间，每次也都是简简单单的 <code>gcc test.cpp</code> 这样简单的命令，偶尔会用一下 <code>-o</code>。说实话C和C++写的确实也不多，大一的时候还处于懵懂时期，跟着老师用VC6，后来面向对象编程之后，几乎工作都在IDE下完成，对这类命令行下的编译指令接触更是甚少。如今才体会到什么叫书到用时方恨少，不得不回过头来再打基础，认真学习。</p>
<p>鉴于这不是一篇Tutorial，只是我的一篇笔记，所以并不会涵盖所有内容。</p>
<h3 id="-">基础</h3>
<p>gcc 命令只能编译 C++ 源文件，而不能自动和 C++ 程序使用的库连接。因此，通常使用 g++ 命令来完成 C++ 程序的编译和连接，该程序会自动调用 gcc 实现编译。</p>
<p>一般来讲，编译过程分为四个阶段：预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。下面举几个例子，关于参数的详细解释在文后会有。</p>
<p><strong>预编译</strong></p>
<pre><code>:::Bash
gcc -E test.c -o test.i 或 gcc -E test.c
</code></pre><p>预编译之后的文件还是代码文件，比如将会将 <code>stdio.h</code> 文件中的内容插入到自己程序中。</p>
<p><strong>编译</strong></p>
<pre><code>:::Bash
gcc -S test.i -o test.s
</code></pre><p><strong>汇编</strong></p>
<pre><code>:::Bash
gcc -c test.s -o test.o
</code></pre><p><strong>连接</strong></p>
<pre><code>:::Bash
gcc test.o -o test
</code></pre><h3 id="-">库文件</h3>
<p>函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。Linux下的大多数函数都默认将头文件放到 <code>/usr/include/</code> 目录下，而库文件则放到 <code>/usr/lib/</code> 目录下；Windows所使用的库文件主要放在Visual Stido的目录下的 <code>include</code> 和 <code>lib</code> ，以及系统文件夹下。放在 <code>/lib</code> 和 <code>/usr/lib</code> 和 <code>/usr/local/lib</code> 里的库直接用 <code>-l</code> 参数就能链接了（关于 <code>-l</code> 参数见文后详解）。</p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>静态库链接搜索路径顺序：</p>
<ol>
<li>参数-L</li>
<li>gcc的环境变量LIBRARY_PATH</li>
<li>内定目录 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code> ，这是当初compile gcc时写在程序内的</li>
</ol>
<p>动态链接时、执行时搜索路径顺序:</p>
<ol>
<li>编译目标代码时指定的动态库搜索路径</li>
<li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li>
<li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li>
<li>默认的动态库搜索路径 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code></li>
</ol>
<p>有关环境变量：</p>
<ul>
<li><code>LIBRARY_PATH</code> ：指定程序静态链接库文件搜索路径</li>
<li><code>LD_LIBRARY_PATH</code> ：指定程序动态链接库文件搜索路径</li>
</ul>
<h3 id="-">参数</h3>
<p>先看几个比较重要的，常用的。</p>
<p><span class="label label-info">-l 和 -L</span></p>
<p><code>-l</code> 用来指定连接的库，其后紧跟<strong>库名</strong>。库名是把真实文件名的头部 <code>lib</code> 和尾部 <code>.so</code> 去掉，如要链接 <code>libmysqlclient.so</code> 库，则应使用 <code>-lmysqlclient</code> 命令。其中，放在 <code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code> 中的库可以直接调用（见上一部分中的搜索路径说明）。然而，放在其它目录的库则需要使用 <code>-L</code> 调用，其使用方法是在 -L 后紧跟<strong>库目录</strong>。</p>
<p><span class="label label-info">-o FILE</span></p>
<p>生成指定的输出可执行文件。</p>
<p><span class="label label-info">-include 和 -I</span></p>
<p><code>-include</code> 用来包含头文件，但一般情况下包含头文件都在源码里用 #include 实现。-I参数是用来指定<strong>头文件目录</strong>，路径参数可以使用绝对路径，也可以使用相对路径。</p>
<p>头文件的搜索路径顺序：</p>
<ol>
<li>参数-I</li>
<li>gcc的环境变量 C_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJC_INCLUDE_PATH</li>
<li>内定目录<ul>
<li>/usr/include  </li>
<li>/usr/local/include</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/include</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../include/g++-3</li>
<li>/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../i386-linux/include</li>
</ul>
</li>
</ol>
<p><span class="label label-info">-O</span></p>
<ul>
<li>-O0 不进行优化处理。 </li>
<li>-O 或 -O1 优化生成代码。 </li>
<li>-O2 进一步优化。 </li>
<li>-O3 比 -O2 更进一步优化，包括 inline 函数。 </li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><span class="label label-info">-w</span> ：不生成任何警告信息。 </li>
<li><span class="label label-info">-Wall</span> ：生成所有警告信息。</li>
<li><span class="label label-info">-DMACRO</span> ：以字符串“1”定义 MACRO 宏。 </li>
<li><span class="label label-info">-DMACRO=DEFN</span> ：以字符串“DEFN”定义 MACRO 宏。</li>
<li><span class="label label-info">-c</span> ：只编译并生成目标文件。 </li>
<li><span class="label label-info">-E</span> ：只运行 C 预编译器。 </li>
<li><span class="label label-info">-g</span> ：生成调试信息。GNU 调试器可利用该信息。 </li>
<li><span class="label label-info">-m486</span> ：针对 486 进行代码优化。 </li>
<li><span class="label label-info">-shared</span> ：生成共享目标文件。通常用在建立共享库时。 </li>
<li><span class="label label-info">-static</span> ：强制使用静态链接。 </li>
<li><span class="label label-info">-UMACRO</span> ：取消对 MACRO 宏的定义。</li>
<li><span class="label label-info">-ansi</span> ：只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色，例如 asm 或 typeof 关键词。 </li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-04T04:35:00.000Z"><a href="/2013/03/boost-thread/">Mar 3 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/boost-thread/">Boost Thread</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这是一篇方法总结和作业笔记，已备需要的时候查阅。本文将介绍C++ Boost库 <code>Boost.Thread</code> ，用于开发独立于平台的多线程应用程序。</p>
<h3 id="-">线程创建</h3>
<p>相关类为 <code>boost::thread</code> ，定义在 <code>boost/thread.hpp</code> 中，用于创建一个新线程。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        std::cout &lt;&lt; i &lt;&lt; std::endl; 
    } 
} 

int main() 
{ 
    boost::thread t(thread); 
    t.join(); 
} 
</code></pre><p><strong>Notes:</strong></p>
<p>一旦上面例子中的变量 <code>t</code> 被创建，该 <code>thread()</code> 函数就在其所在线程中被立即执行， <code>join()</code> 的方法跟POSIX pthread中意义一样。</p>
<h3 id="-">线程中断</h3>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    try 
    { 
        for (int i = 0; i &lt; 5; ++i) 
        { 
            wait(1); 
            std::cout &lt;&lt; i &lt;&lt; std::endl; 
        } 
    } 
    catch (boost::thread_interrupted&amp;) 
    { 

} 

int main() 
{ 
    boost::thread t(thread); 
    wait(3); 
    t.interrupt(); 
    t.join(); 
} 
</code></pre><p>在一个线程对象上调用 <code>interrupt()</code> 会中断相应的线程，就是说一个类型为 <code>boost::thread_interrupted</code> 的异常会在这个线程中抛出。 然后这只有在线程达到中断点时才会发生。如果给定的线程不包含任何中断点，简单调用 <code>interrupt()</code> 就不会起作用。每当遇到一个线程中断点，它就会检查 <code>interrupt()</code> 是否被调用过。只有被调用过了， <code>boost::thread_interrupted</code> 异常才会相应地抛出。</p>
<p>下列函数中包含线程的中断检查点：</p>
<ul>
<li>boost::thread::join()</li>
<li>boost::thread::timed_join()</li>
<li>boost::thread::try_join_for(),</li>
<li>boost::thread::try_join_until(),</li>
<li>boost::condition_variable::wait()</li>
<li>boost::condition_variable::timed_wait()</li>
<li>boost::condition_variable::wait_for()</li>
<li>boost::condition_variable::wait_until()</li>
<li>boost::condition_variable_any::wait()</li>
<li>boost::condition_variable_any::timed_wait()</li>
<li>boost::condition_variable_any::wait_for()</li>
<li>boost::condition_variable_any::wait_until()</li>
<li>boost::thread::sleep()</li>
<li>boost::this_thread::sleep_for()</li>
<li>boost::this_thread::sleep_until()</li>
<li>boost::this_thread::interruption_point()</li>
</ul>
<h3 id="-">同步</h3>
<p>设计到线程的地方就会出现竞争条件(race condition)，所以进行同步是必不可少的。</p>
<p>最简单的 <code>boost::mutex</code> 类。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

boost::mutex mutex; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        mutex.lock(); 
        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
        mutex.unlock(); 
    } 
} 

int main() 
{ 
    boost::thread t1(thread); 
    boost::thread t2(thread); 
    t1.join(); 
    t2.join(); 
} 
</code></pre><p>也可以使用 <code>boost::lock_guard</code> 类，来避免直接调用 <code>lock()</code> 和 <code>unlock()</code> 。</p>
<pre><code>:::CPP
#include &lt;boost/thread.hpp&gt; 
#include &lt;iostream&gt; 

boost::mutex mutex; 

void wait(int seconds) 
{ 
    boost::this_thread::sleep(boost::posix_time::seconds(seconds)); 
} 

void thread() 
{ 
    for (int i = 0; i &lt; 5; ++i) 
    { 
        wait(1); 
        boost::lock_guard&lt;boost::mutex&gt; lock(mutex); 
        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; boost::this_thread::get_id() &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; 
    } 
} 

int main() 
{ 
    boost::thread t1(thread); 
    boost::thread t2(thread); 
    t1.join(); 
    t2.join(); 
} 
</code></pre><p><code>boost::lock_guard</code> 在其构造和析构函数分别自动调用 <code>lock()</code> 和 <code>unlock()</code> 。</p>
<h3 id="reference">Reference</h3>
<ul>
<li><p>Boost多线程 <a href="http://zh.highscore.de/cpp/boost/" target="_blank"><a href="http://zh.highscore.de/cpp/boost/">http://zh.highscore.de/cpp/boost/</a></a></p>
</li>
<li><p>Boost Thread Documentation <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html" target="_blank"><a href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></a></p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-12T03:48:00.000Z"><a href="/2013/02/ipc-semaphores/">Feb 11 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/ipc-semaphores/">IPC Semaphores</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="initializing-a-semaphore-set">Initializing a Semaphore Set</h3>
<p>The function <code>semget()</code> initializes or gains access to a semaphore.</p>
<pre><code>:::C
int semget(key_t key, int nsems, int semflg);
</code></pre><ul>
<li><p>The <code>key</code> argument is a access value associated with the semaphore ID.</p>
</li>
<li><p>The <code>nsems</code> argument specifies the number of elements in a semaphore array. The call fails when nsems is greater than the number of elements in an existing array; when the correct count is not known, supplying 0 for this argument ensures that it will succeed.</p>
</li>
<li><p>The <code>semflg</code> argument specifies the initial access permissions and creation control flags.</p>
</li>
</ul>
<p>When the call succeeds, it returns the semaphore ID (semid).</p>
<pre><code>:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
key_t key; /* key to pass to semget() */ 
int semflg; /* semflg to pass tosemget() */ 
int nsems; /* nsems to pass to semget() */ 
int semid; /* return value from semget() */ 

... 

key = 123456; 
nsems = 1;
semflg = IPC_CREAT | 0666; // Flag to create with rw permissions
// Create the semaphore
// The return value is the semaphore set identifier
if ((semid = semget(key, nsems, semflg)) == -1) {
    perror(&quot;semget: semget failed&quot;); 
     exit(1); 
} 
else 
   ...
</code></pre><h3 id="controlling-semaphores">Controlling Semaphores</h3>
<p><code>semctl()</code> changes permissions and other characteristics of a semaphore set. It is prototyped as follows:</p>
<pre><code>:::C
int semctl(int semid, int semnum, int cmd, union semun arg);
</code></pre><p>It must be called with a valid semaphore ID, semid. The <code>semnum</code> value selects a semaphore within an array by its index. The <code>cmd</code> argument is one of the following control flags:</p>
<p>GETVAL
-- Return the value of a single semaphore.</p>
<p>SETVAL
-- Set the value of a single semaphore. In this case, arg is taken as arg.val, an int.</p>
<p>GETPID
-- Return the PID of the process that performed the last operation on the semaphore or array.</p>
<p>GETNCNT
-- Return the number of processes waiting for the value of a semaphore to increase.</p>
<p>GETZCNT
-- Return the number of processes waiting for the value of a particular semaphore to reach zero.</p>
<p>GETALL
-- Return the values for all semaphores in a set. In this case, arg is taken as arg.array, a pointer to an array of unsigned shorts (see below).</p>
<p>SETALL
-- Set values for all semaphores in a set. In this case, arg is taken as arg.array, a pointer to an array of unsigned shorts.</p>
<p>IPC_STAT
-- Return the status information from the control structure for the semaphore set and place it in the data structure pointed to by arg.buf, a pointer to a buffer of type semid_ds.</p>
<p>IPC_SET
-- Set the effective user and group identification and permissions. In this case, arg is taken as arg.buf.</p>
<p>IPC_RMID
-- Remove the specified semaphore set.</p>
<p>The fourth argument <code>union semun</code> arg is optional, depending upon the operation requested. If required it is of type union semun, which must be explicitly declared by the application program as:</p>
<pre><code>:::C
union semun {
   int val;
   struct semid_ds *buf;
   ushort *array;
} arg;

:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt; 

// Initialize the semaphore
union semun {
   int val;
   struct semid_ds *buf;
   ushort *array;
} arg;

int semnum = ....;
int cmd = GETALL;   /* get value */

... 
if (semctl(semid, semnum, cmd, arg) &lt; 0) { 
    perror(&quot;semctl: semctl failed&quot;); 
    exit(1); 
}
else
    ...
</code></pre><h3 id="semaphore-operations">Semaphore Operations</h3>
<p><code>semop()</code> performs operations on a semaphore set.</p>
<pre><code>:::C
int semop(int semid, struct sembuf *sops, size_t nsops);
</code></pre><p>The <code>sops</code> argument is a pointer to an array of structures, each containing the following information about a semaphore operation:</p>
<pre><code>:::C
The semaphore number
The operation to be performed
Control flags, if any.
</code></pre><p>The <code>sembuf</code> structure specifies a semaphore operation, as defined in <code>sys/sem.h</code>.</p>
<pre><code>:::C
struct sembuf {
    ushort_t    sem_num;        /* semaphore number */
    short       sem_op;         /* semaphore operation */
    short       sem_flg;        /* operation flags */
};
</code></pre><p>The operation to be performed is determined as follows:</p>
<pre><code>:::C
A positive integer increments the semaphore value by that amount.
A negative integer decrements the semaphore value by that amount. An attempt to set a semaphore to a value less than zero fails or blocks, depending on whether IPC_NOWAIT is in effect.
A value of zero means to wait for the semaphore value to reach zero.


:::C
#include &lt;sys/types.h&gt; 
#include &lt;sys/ipc.h&gt; 
#include &lt;sys/sem.h&gt; 

... 
int i; 
int nsops; /* number of operations to do */ 
int semid; /* semid of semaphore set */ 
struct sembuf *sops; /* ptr to operations to perform */ 

... 
// semop performs the operations on the semaphore:
if ((semid = semop(semid, sops, nsops)) == -1) 
{ 
    perror(&quot;semop: semop failed&quot;); 
    exit(1);
} 
else 
    (void) fprintf(stderr, &quot;semop: returned %d\n&quot;, i); 
    ...
</code></pre><h3 id="-">补充</h3>
<p>以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。</p>
<p>在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。</p>
<p>抽象的来讲，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程/进程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-05T23:04:00.000Z"><a href="/2013/02/make-your-program/">Feb 5 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/make-your-program/">Make Your Program</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这学期选了两门挺有意思的课，一门叫Programming High Performance Computing，还有一门Parallel and Distributed Processing。两周刚刚上下来，感觉传递的知识量有我之前悠哉悠哉一学期学到的都多。不知道是美国本科生的基础好还是美国大学的教育好，同班的美国同学接受这些知识看起来都毫无压力。不过语言确实是一个因素，比如HPC的老师两节课讲了几十个英文缩写，还都与电路有关，感觉回到了当年狂补计算机组成原理的时候。这些英文缩写估计对于美国学生接受起来要更好一点吧。我只有更努力了。</p>
<p>重新好好学习一下以前的知识，认真记住。PDP的教授第一节课说了一句话让我印象非常深刻，他说：“They value you not because what you can search but what you can do.”其实非常羡慕老教授课堂上信手拈来的各种复杂代码和命令参数，只靠Google是不行的。</p>
<p>本篇博客就来复习一下Makefile吧，这两门课每次交作业都要求必须包含Makefile，就像HPC的Slides中说的：“Real programmers use Makefiles!”</p>
<h3 id="outline">Outline</h3>
<ul>
<li><p>What&#39;s Makefile</p>
</li>
<li><p>Generating Multiple Targets</p>
</li>
<li><p>Macros</p>
</li>
</ul>
<h3 id="what-s-makefile">What&#39;s Makefile</h3>
<p>Under the UNIX shell, make is a command generator. The makefile is a description file which creates a sequence of commands for execution by the UNIX shell.</p>
<p>Generally, a program is built from one or more files and each of these files may have other files as prerequisites in turn. In a makefile, the prerequisites should be carefully stated. There are two important types of lines in a description file. A dependency line or rule line contains a colon, and a command line always starts <strong>with a tab</strong>.</p>
<p>To the left of the colon on the dependency line is a target; to the right of the colon are the target&#39;s prerequisites. If myprog has prerequisites a.c and b.c, we have</p>
<pre><code> myprog :  a.c  b.c
</code></pre><p>The command lines just tells make how to make the target. For example,</p>
<pre><code> myprog : a.c b.c
      gcc -o myprog a.c b.c
</code></pre><p>Then, type <code>make</code>, the UNIX prompt will excute the command as you typed.</p>
<h3 id="generating-multiple-targets">Generating Multiple Targets</h3>
<p>If we want to generate more than one programs, for example, let program prog01 depend on a.c and b.c, prog02 depend on m.c and n.c, and prog03 depend on u.c, v.c and w.c. </p>
<pre><code> all : prog01 prog02 prog03

 prog01 : a.c b.c
      gcc -o prog01 a.c b.c

 prog02 : m.c n.c
      gcc -o prog02 m.c n.c

 prog03 : u.c v.c w.c
      gcc -o prog03 u.c v.c w.c
</code></pre><p>Thus, if one of these three programs is not up-to-date, <code>all</code> will be generated which in turn causes all programs compiled. If the dependency line defining <code>all</code> is the first line of your Makefile, just type <code>make</code> will be the same as typing <code>make all</code>.</p>
<h3 id="macros">Macros</h3>
<p>A macro definition is a line containing an equal sign (=). When make encounters a name that appears to the left of the equal sign, that name is replaced by the contents to the right of the equal sign. It is not necessary to delimit the text string with double quote (&quot;) or single quote (&#39;). If they are used, they become part of the text string.</p>
<p>If we have the macro definition as follows,</p>
<pre><code> NAME = Zhaoyu Li
</code></pre><p>Then subsequent references to <code>${NAME}</code> or <code>$(NAME)</code> are interpreted as <code>Zhaoyu Li</code>.</p>
<h3 id="examples">Examples</h3>
<p>Here are two examples,</p>
<pre><code> SUBDIRS = src analyze

 all: subdirs test analysis
      @echo &quot;After Build, run &#39;make analysis&#39; to run analysis&quot;

 test: 
      @echo &quot;About to self-test&quot;; ./src/hw1

 analysis: 
      @cd analyze &amp;&amp; make analysis

 subdirs:
      @for dir in $(SUBDIRS); do \
           $(MAKE) -C $$dir; \
      done

 clean:
      @for dir in $(SUBDIRS); do \
           $(MAKE) -C $$dir clean; \
      done
</code></pre><p>Let&#39;s see another example. Suppose you are provided with two files, MyThreads.h and MyThreads.o. The former is a header file that has to be included into your source files and the latter is a library of functions for you to use. In other words, your source files in which multithreaded capability is used depend on MyThreads.h and your executable depends on MyThreads.o.</p>
<p>Suppose your assignment has the following files, prog01.c (the main function), and abc.c, def.c and xyz.c. All of these files contain access to multithread functions defined in MyThreads.h. You also designed some utility functions collected in files ut1.c and ut2.c. None of these two have access to the multithread capability. However, in your judgment, you believe any change made to ut1.c and ut2.c requires recompilation of abc.c and xyz.c. Therefore, on the source level, prog01.c, abc.c, def.c and xyz.c depend on MyThreads.h, and abc.c and xyz.c also depend on ut1.c and ut2.c. Suppose the final executable is to be called prog01.</p>
<pre><code> CC = gcc -ansi

 prog01 : prog01.o abc.o def.o xyz.o ut1.o ut2.o MyThreads.o
      ${CC} -o prog01 prog01.o abc.o def.o xyz.o ut1.o ut2.o MyThreads.o -lthread

 prog01.o : prog01.c MyThreads.h
      ${CC} -c prog01.c

 abc.o : abc.c c ut2.c MyThreads.h
      ${CC} -c abc.c
 def.o : def.c MyThreads.h
      ${CC} -c def.c
 xyz.o : xyz.c ut1.c ut2.c MyThreads.h
      ${CC} -c xyz.c

 ut1.o : ut1.c
      ${CC} -c ut1.c
 ut2.o : ut2.c
      ${CC} -c ut2.c
</code></pre><p>Above is the basic concepts of Makefile. If you want to be more expert, try the offcial documents.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-02-03T00:35:00.000Z"><a href="/2013/02/posix-threads-programming/">Feb 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/02/posix-threads-programming/">POSIX Threads Programming</a></h1>
  

    </header>
    <div class="entry">
      
        <p>I am writing this article for a memo of CS8860, Parallel and distributed system.</p>
<h3 id="overview">Overview</h3>
<p>Technically, a thread is defined as an independent stream of instructions that can be scheduled to run as such by the operating system.</p>
<p>In the UNIX environment a thread:</p>
<ul>
<li><p>Exists within a process and uses the process resources</p>
</li>
<li><p>Has its own independent flow of control as long as its parent process exists and the OS supports it</p>
</li>
<li><p>Duplicates only the essential resources it needs to be independently schedulable</p>
</li>
<li><p>May share the process resources with other threads that act equally independently (and dependently)</p>
</li>
<li><p>Dies if the parent process dies - or something similar</p>
</li>
<li><p>Is &quot;lightweight&quot; because most of the overhead has already been accomplished through the creation of its process.</p>
</li>
</ul>
<p>All threads within a process share the same address space.</p>
<h3 id="several-common-models">Several common models</h3>
<p>Several common models for threaded programs exist:</p>
<ul>
<li><p><strong>Manager/worker:</strong> a single thread, the manager assigns work to other threads, the workers. Typically, the manager handles all input and parcels out work to the other tasks. At least two forms of the manager/worker model are common: static worker pool and dynamic worker pool.</p>
</li>
<li><p><strong>Pipeline:</strong> a task is broken into a series of suboperations, each of which is handled in series, but concurrently, by a different thread. An automobile assembly line best describes this model.</p>
</li>
<li><p><strong>Peer:</strong> similar to the manager/worker model, but after the main thread creates other threads, it participates in the work.</p>
</li>
</ul>
<h3 id="shared-memory-model-">Shared Memory Model:</h3>
<ul>
<li><p>All threads have access to the same global, shared memory</p>
</li>
<li><p>Threads also have their own private data</p>
</li>
<li><p>Programmers are responsible for synchronizing access (protecting) globally shared data.</p>
</li>
</ul>
<h3 id="the-pthreads-api">The Pthreads API</h3>
<p>The Pthreads API contains around 100 subroutines. This article will focus on a subset of these.</p>
<h3 id="compiling-threaded-programs">Compiling Threaded Programs</h3>
<pre><code>INTEL Linux:          icc -pthread
PGI Linux:            pgcc -lpthread
GNU Linux:            gcc -pthread
</code></pre><h3 id="threading-management">Threading Management</h3>
<p><strong> Creating and Terminating Threads </strong></p>
<p>Initially, your <code>main()</code> program comprises a single, default thread. All other threads must be explicitly created by the programmer.</p>
<p><code>pthread_create</code> creates a new thread and makes it executable. This routine can be called any number of times from anywhere within your code.</p>
<p><code>pthread_create</code> arguments:</p>
<ul>
<li><p><code>thread:</code> An opaque, unique identifier for the new thread returned by the subroutine.</p>
</li>
<li><p><code>attr:</code> An opaque attribute object that may be used to set thread attributes. You can specify a thread attributes object, or NULL for the default values.</p>
</li>
<li><p><code>start_routine:</code> the C routine that the thread will execute once it is created.</p>
</li>
<li><p><code>arg:</code> A single argument that may be passed to start_routine. It must be passed by reference as a pointer cast of type void. NULL may be used if no argument is to be passed.</p>
</li>
</ul>
<p>Once created, threads are peers, and may create other threads. There is no implied hierarchy or dependency between threads.</p>
<p>There are several ways in which a thread may be terminated:</p>
<ul>
<li><p>The thread returns normally from its starting routine. It&#39;s work is done.</p>
</li>
<li><p>The thread makes a call to the <code>pthread_exit</code> subroutine - whether its work is done or not.</p>
</li>
<li><p>The thread is canceled by another thread via the <code>pthread_cancel</code> routine.</p>
</li>
<li><p>The entire process is terminated due to making a call to either the <code>exec()</code> or <code>exit()</code></p>
</li>
<li><p>If <code>main()</code> finishes first, without calling <code>pthread_exit</code> explicitly itself</p>
</li>
</ul>
<p>Pay attention, the pthread_exit() routine does not close files; any files opened inside the thread will remain open after the thread is terminated.</p>
<p>Example:</p>
<pre><code>#include &lt;pthread.h&gt; 
#include &lt;stdio.h&gt; 
#define NUM_THREADS  5 

void *PrintHello(void *threadid) 
{ 
   int tid; 
   tid = (int)threadid; 
   printf(&quot;Hello World! It&#39;s me, thread #%d!\n&quot;, tid); 
   pthread_exit(NULL); 
} 

int main (int argc, char *argv[]) 
{ 
   pthread_t threads[NUM_THREADS]; 
   int rc, t; 
   for(t=0; t&lt;NUM_THREADS; t++){ 
      printf(&quot;In main: creating thread %d\n&quot;, t); 
      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t); 
      if (rc){ 
         printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc); 
         exit(-1); 
      } 
   } 
   pthread_exit(NULL); 
}
</code></pre><p><strong> Passing Arguments to Threads </strong></p>
<p>All arguments must be passed by reference and cast to (void *).</p>
<p><strong> Joining and Detaching Threads </strong></p>
<pre><code>:::C
int pthread_join(pthread_t target_thread, void **status);
</code></pre><p>&quot;Joining&quot; is one way to accomplish synchronization between threads. This means that some other thread is required to call pthread_join to collect a terminated thread, in a fashion similar to the requirement for a parent process to collect status for terminated child processes.For example:</p>
<p><a href="/images/2013/02/forkjoin.gif"><img src="/images/2013/02/forkjoin.gif" alt=""></a></p>
<p>The <code>pthread_join()</code> subroutine blocks the calling thread until the specified threadid thread terminates.</p>
<p>To explicitly create a thread as joinable or detached, the attr argument in the <code>pthread_create()</code> routine is used. The typical 4 step process is:</p>
<ul>
<li><p>Declare a pthread attribute variable of the <code>pthread_attr_t</code> data type</p>
</li>
<li><p>Initialize the attribute variable with <code>pthread_attr_init()</code></p>
</li>
<li><p>Set the attribute detached status with <code>pthread_attr_setdetachstate()</code></p>
</li>
<li><p>When done, free library resources used by the attribute with p<code>thread_attr_destroy()</code></p>
</li>
</ul>
<p>Example:</p>
<pre><code>:::C
/*****************************************************************************
 * FILE: join.c
 * DESCRIPTION:
 *   This example demonstrates how to &quot;wait&quot; for thread completions by using
 *   the Pthread join routine.  Threads are explicitly created in a joinable
 *   state for portability reasons. Use of the pthread_exit status argument is
 *   also shown. Compare to detached.c
 * AUTHOR: 8/98 Blaise Barney
 * LAST REVISED:  01/30/09
 ******************************************************************************/
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define NUM_THREADS    4

void *BusyWork(void *t)
{
    int i;
    long tid;
    double result=0.0;
    tid = (long)t;
    printf(&quot;Thread %ld starting...\n&quot;,tid);
    for (i=0; i&lt;1000000; i++)
    {
        result = result + sin(i) * tan(i);
    }
    printf(&quot;Thread %ld done. Result = %e\n&quot;,tid, result);
    pthread_exit((void*) t);
}

int main (int argc, char *argv[])
{
    pthread_t thread[NUM_THREADS];
    pthread_attr_t attr;
    int rc;
    long t;
    void *status;

    /* Initialize and set thread detached attribute */
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

    for(t=0; t&lt;NUM_THREADS; t++) {
        printf(&quot;Main: creating thread %ld\n&quot;, t);
        rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, (void *)t);
        if (rc) {
            printf(&quot;ERROR; return code from pthread_create() is %d\n&quot;, rc);
            exit(-1);
        }
    }

    /* Free attribute and wait for the other threads */
    pthread_attr_destroy(&amp;attr);
    for(t=0; t&lt;NUM_THREADS; t++) {
        rc = pthread_join(thread[t], &amp;status);
        if (rc) {
            printf(&quot;ERROR; return code from pthread_join() is %d\n&quot;, rc);
            exit(-1);
        }
        printf(&quot;Main: completed join with thread %ld having a status of %ld\n&quot;,t,(long)status);
    }

    printf(&quot;Main: program completed. Exiting.\n&quot;);
    pthread_exit(NULL);
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:hackecho.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/04/hadoop-cluster-setup-instruction-with-fedora-20/">Hadoop Cluster Setup Instruction with Fedora 20</a>
      </li>
    
      <li>
        <a href="/2013/10/real-time-emotion-analysis-on-twitter/">Real-time Emotion Analysis On Twitter</a>
      </li>
    
      <li>
        <a href="/2013/04/cuda-parallel-reduction/">CUDA中并行规约（Parallel Reduction）的优化</a>
      </li>
    
      <li>
        <a href="/2013/04/basics-of-mpi/">MPI 并行程序设计基础</a>
      </li>
    
      <li>
        <a href="/2013/03/a-letter-to-myself/">写给四年前刚开始编程的自己</a>
      </li>
    
      <li>
        <a href="/2013/03/basic-of-gcc/">GCC 基础</a>
      </li>
    
      <li>
        <a href="/2013/03/boost-thread/">Boost Thread</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">Links</h3>
<ul class="entry">
	<li><a href="http://vicdory.com/" target="_blank" title="Kailun Shi">Kailun Shi</a></li>
	<li><a href="http://guo-min-zhi.github.io/" target="_blank" title="远方">远方</a></li>
	<li><a href="http://mingplusplus.com/blog/" target="_blank" title="Ming++">Ming++</a></li>
	<li><a href="http://ruiwu.me/" target="_blank" title="RuiWu">RuiWu</a></li>
</ul>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Android,AsyncTask/">Android,AsyncTask</a><small>1</small></li>
  
    <li><a href="/tags/Android,SharedPreferences/">Android,SharedPreferences</a><small>1</small></li>
  
    <li><a href="/tags/BidData/">BidData</a><small>1</small></li>
  
    <li><a href="/tags/Decorator,Python/">Decorator,Python</a><small>1</small></li>
  
    <li><a href="/tags/GBK,Mac,UTF8/">GBK,Mac,UTF8</a><small>1</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
  
    <li><a href="/tags/Google+/">Google+</a><small>1</small></li>
  
    <li><a href="/tags/Hadoop/">Hadoop</a><small>1</small></li>
  
    <li><a href="/tags/JSON,XML,PHP/">JSON,XML,PHP</a><small>1</small></li>
  
    <li><a href="/tags/Life/">Life</a><small>1</small></li>
  
    <li><a href="/tags/Linux,HFS/">Linux,HFS</a><small>1</small></li>
  
    <li><a href="/tags/MPI/">MPI</a><small>1</small></li>
  
    <li><a href="/tags/MVC, PHP/">MVC, PHP</a><small>1</small></li>
  
    <li><a href="/tags/PHP,Socket/">PHP,Socket</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>1</small></li>
  
    <li><a href="/tags/ThinkPHP/">ThinkPHP</a><small>1</small></li>
  
    <li><a href="/tags/WebSocket,HTML5/">WebSocket,HTML5</a><small>1</small></li>
  
    <li><a href="/tags/Wordpress/">Wordpress</a><small>2</small></li>
  
    <li><a href="/tags/boost,thread/">boost,thread</a><small>1</small></li>
  
    <li><a href="/tags/cuda,parallel,reduction/">cuda,parallel,reduction</a><small>1</small></li>
  
    <li><a href="/tags/fly-of-promgrammer/">fly-of-promgrammer</a><small>1</small></li>
  
    <li><a href="/tags/gcc/">gcc</a><small>1</small></li>
  
    <li><a href="/tags/ipc,semaphores/">ipc,semaphores</a><small>1</small></li>
  
    <li><a href="/tags/life/">life</a><small>1</small></li>
  
    <li><a href="/tags/makefile/">makefile</a><small>1</small></li>
  
    <li><a href="/tags/movie/">movie</a><small>1</small></li>
  
    <li><a href="/tags/open source/">open source</a><small>1</small></li>
  
    <li><a href="/tags/pthread/">pthread</a><small>1</small></li>
  
    <li><a href="/tags/web/">web</a><small>1</small></li>
  
    <li><a href="/tags/websocket/">websocket</a><small>1</small></li>
  
    <li><a href="/tags/极客/">极客</a><small>1</small></li>
  
    <li><a href="/tags/程序员/">程序员</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 Zhaoyu Li
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'zlmoment';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- InstantClick makes following links in your website instant. http://instantclick.io -->
<script src="/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
</body>
</html>